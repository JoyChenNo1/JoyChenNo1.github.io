<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><!-- hexo injector head_begin start --><link href="/css/tag-common/index.css" rel="stylesheet"/><!-- hexo injector head_begin end --><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>拆书系列之《深度探索 C++ 对象模型》 | JoyChen's 知识星球</title><meta name="author" content="JoyChen"><meta name="copyright" content="JoyChen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="拆书系列之《深度探索 C++ 对象模型》参考自《深度探索 C++ 对象模型》--Stanley B.Lippman 著，侯捷译。   关于对象（Object Lessons）本章主要泛讲 C++的对象模型、struct 和 class 关键字的差异、多态下的内存布局分析等。 加上封装后的布局成本C+"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/10/08/C++%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20C++%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '拆书系列之《深度探索 C++ 对象模型》',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-18 19:35:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/a/a1.png')"><nav id="nav"><span id="blog-info"><a href="/" title="JoyChen's 知识星球"><span class="site-name">JoyChen's 知识星球</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">拆书系列之《深度探索 C++ 对象模型》</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-08T06:20:00.000Z" title="发表于 2021-10-08 14:20:00">2021-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-18T11:35:00.506Z" title="更新于 2023-02-18 19:35:00">2023-02-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="拆书系列之《深度探索-C-对象模型》"><a href="#拆书系列之《深度探索-C-对象模型》" class="headerlink" title="拆书系列之《深度探索 C++ 对象模型》"></a>拆书系列之《深度探索 C++ 对象模型》</h1><p><code>参考自《深度探索 C++ 对象模型》--Stanley B.Lippman 著，侯捷译。</code></p>
<br/>

<h2 id="关于对象（Object-Lessons）"><a href="#关于对象（Object-Lessons）" class="headerlink" title="关于对象（Object Lessons）"></a>关于对象（Object Lessons）</h2><p><code>本章主要泛讲 C++的对象模型、struct 和 class 关键字的差异、多态下的内存布局分析等。</code></p>
<h3 id="加上封装后的布局成本"><a href="#加上封装后的布局成本" class="headerlink" title="加上封装后的布局成本"></a>加上封装后的布局成本</h3><p>C++ 在布局以及存取时间上的主要的额外负担由 <strong>virtual</strong> 引起，包括：</p>
<p><code>virtual function 机制， 用来支持 执行期绑定。</code></p>
<p><code>virtual base class， 用来实现单一共享在继承体系中。</code></p>
<p>此外，还有一些额外负担，发生在 <code>一个 derived class 和之上的 base class 转换之间。</code></p>
<br/>

<h2 id="C-对象模式（The-C-Object-Model）"><a href="#C-对象模式（The-C-Object-Model）" class="headerlink" title="C++ 对象模式（The C++ Object Model）"></a>C++ 对象模式（The C++ Object Model）</h2><p>Stroustrup 当初设计的 C++ 对象模型中， <strong>非静态数据成员（nonstatic data members）</strong> 被配置于每一个 <strong>类实例化对象（class object）</strong> 之内，<strong>静态数据成员（static data members）</strong> 、<strong>静态和非静态成员函数（static and nonstatic function members）</strong> 被存放在类实例化对象（class object）之外。</p>
<p>虚函数通过两个步骤来支持：</p>
<p>1、每一个 <strong>类</strong> 产生一堆指向 <strong>virtual functions</strong> 的指针，放在 <strong>表格（virtual table，缩写 vtbl）</strong> 中。</p>
<p>2、每一个 <strong>类实例化对象</strong> 被天际一个 <strong>指针（vptr）</strong>，指向 <strong>virtual table</strong>，<strong>vptr</strong> 的设定和重置都有类的 <strong>constructor、destructor 和 copy assignment 运算符</strong> 自动完成。 每个 <strong>类</strong>所关联的 <strong>type_info object （用以支持 runtime type identification， RTTI）</strong>也通过 <strong>virtual table</strong> 被指出来，通常放在 <strong>virtual table</strong> 的第一个 slot 处。</p>
<br/>





<h3 id="C-对象模型（The-C-Object-Model）"><a href="#C-对象模型（The-C-Object-Model）" class="headerlink" title="C++ 对象模型（The C++ Object Model）"></a>C++ 对象模型（The C++ Object Model）</h3><p>比如一个类 <strong>Point</strong>：</p>
<div class="tabs" id="point"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="point-1">class Point</button><button type="button" class="tab " data-href="point-2">class Point 对象模型</button></ul><div class="tab-contents"><div class="tab-item-content active" id="point-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">float</span> xval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">PointCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> ostream<span class="token operator">&amp;</span> <span class="token function">Print</span><span class="token punctuation">(</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

  <span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">float</span> x_<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> point_count_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="point-2"><p>优点：<code>空间及存取时间的效率。</code></p>
<p>缺点：<code>如果用到的 class object 的 nonstatic data members 有修改（增/删/改），应用程序代码需要重新编译。</code></p>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/Point%E7%B1%BB%E6%A8%A1%E5%9E%8B%E5%9B%BE.png"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>

<h3 id="加上继承的-C-对象模型"><a href="#加上继承的-C-对象模型" class="headerlink" title="加上继承的 C++ 对象模型"></a>加上继承的 C++ 对象模型</h3><div class="tabs" id="继承的-c++-对象模型"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="继承的-c++-对象模型-1">单一继承</button><button type="button" class="tab " data-href="继承的-c++-对象模型-2">多重继承</button><button type="button" class="tab " data-href="继承的-c++-对象模型-3">虚拟继承</button><button type="button" class="tab " data-href="继承的-c++-对象模型-4">派生类如何在本质上模塑其基类实体？</button></ul><div class="tab-contents"><div class="tab-item-content active" id="继承的-c++-对象模型-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Library_materials</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Book</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Library_materials</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Rental_book</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Book</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="继承的-c++-对象模型-2"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 一种 iostream 实现方式</span>
<span class="token keyword">class</span> <span class="token class-name">iostream</span><span class="token operator">:</span> 
		<span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">istream</span><span class="token punctuation">,</span> 
		<span class="token keyword">public</span> <span class="token class-name">ostream</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="继承的-c++-对象模型-3"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// virtual -> 共享的意思</span>
<span class="token keyword">class</span> <span class="token class-name">istream</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">ios</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">ostream</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">ios</span></span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在虚拟继承的情况下， base class 不管在继承串链中被派生（derived）多少次，永远只会存在一份实体（subject）。</p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/iostream-class.png"></div><div class="tab-item-content" id="继承的-c++-对象模型-4"><p>每一个 <code>base class</code> 可以被 <code>derived class object</code> 内的一个 <code>slot</code> 指出，该 <code>slot</code> 内含 <code>base class subobject</code> 的地址。</p>
<p>这种体制的主要缺点：因为间接性导致空间和存取时间上的额外负担。</p>
<p>这种体制的主要优点：class object 的大小不会因为其 base classes 的改变而受到影响。</p>
<br/>

<p>另一种所谓的 base table 模型：base class table 被产生出来时，表格中的每一个 slot 内包含一个相关的 base class 地址，这个很想 virtual table 内包含一个 virtual function 的地址一样。每一个 class object 内含一个 bptr，它会被初始化，指向其 base class table。</p>
<p>缺点：因为间接性导致空间和存取时间上的额外负担。</p>
<p>优点：每一个 class object 都应该在某个固定位置安放一个 base table 指针，与 base classes 的大小和数目无关；无需改变 class objects 本身就可以放大、缩小、或者更改 base class table。</p>
<p>base class table 模型在虚拟多继承中的应用</p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/base-class-table-model.png"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<p>不管哪一种体制，<code>间接性</code> 的级数都将因为继承的深度增加（如 Rental_book 需要两次简介存取才能够探取到继承自 Library_metarials 的 members），而 Book 只需要一次。所以，<code>在 derived 内复制一个指针，指向继承串链中的每一个 base class，可以得到一个永恒不变的存取时间</code>，需要的额外空间来放置额外的指针这个代价是必然的。</p>
<br/>



<h3 id="对象模型如何影响程序"><a href="#对象模型如何影响程序" class="headerlink" title="对象模型如何影响程序"></a>对象模型如何影响程序</h3><p>这里先引入了对象模型下一个类可能被转化的一个过程。</p>
<div class="tabs" id="对象模型下的函数转换"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="对象模型下的函数转换-1">假设定义一个类</button><button type="button" class="tab " data-href="对象模型下的函数转换-2">可能在内部的转化</button><button type="button" class="tab " data-href="对象模型下的函数转换-3">转化图示</button></ul><div class="tab-contents"><div class="tab-item-content active" id="对象模型下的函数转换-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  	<span class="token comment">// copy constructor</span>
  	<span class="token function">X</span><span class="token punctuation">(</span><span class="token keyword">const</span> X<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>
  	<span class="token comment">// virtual destructor</span>
  	<span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	<span class="token comment">// virtual function</span>
  	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


X <span class="token function">foobar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  X xx<span class="token punctuation">;</span>
  X <span class="token operator">*</span>px <span class="token operator">=</span> <span class="token keyword">new</span> X<span class="token punctuation">;</span>
  <span class="token comment">// foo 是一个 virtual function</span>
  xx<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  px<span class="token operator">-></span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  	
  <span class="token keyword">delete</span> px<span class="token punctuation">;</span>
  retun xx<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="对象模型下的函数转换-2"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foobar</span><span class="token punctuation">(</span>X <span class="token operator">&amp;</span>_result<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token comment">// 构造 _result</span>
  <span class="token comment">// _result 用来取代 local xx ...</span>
  _result<span class="token punctuation">.</span><span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 扩展 X *px = new X;</span>
  px <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span> px <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span>
    px<span class="token operator">-></span><span class="token class-name">X</span><span class="token double-colon punctuation">::</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 扩展 xx.foo() 但不使用 virtual 机制</span>
  <span class="token comment">// 以 _result 取代 xx</span>
  <span class="token function">foo</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>_result <span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 使用 virtual 机制扩展 px->foo()</span>
  <span class="token punctuation">(</span> <span class="token operator">*</span>px<span class="token operator">-></span>vtbl<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">(</span> px <span class="token punctuation">)</span>
  
  <span class="token comment">// 扩展 delete px;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>px <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">(</span> <span class="token operator">*</span>px<span class="token operator">-></span>vtbl<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">(</span> px <span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">// destructor</span>
    <span class="token function">_delete</span><span class="token punctuation">(</span> px <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">&#125;</span>
  
  <span class="token comment">// 不需要使用 named return statement</span>
  <span class="token comment">// 不需要销毁 local object xx</span>
  <span class="token keyword">return</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="对象模型下的函数转换-3"><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E7%A8%8B%E5%BA%8F.png"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>



<h3 id="关键词所带来的差异"><a href="#关键词所带来的差异" class="headerlink" title="关键词所带来的差异"></a>关键词所带来的差异</h3><p>举例说明了关键字带来的差异，以及 C++ 为了兼容 C 变得复杂的原因。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token punctuation">(</span> <span class="token operator">*</span>p1 <span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不知道是个声明（declaration）还是 函数调用（invocation）</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span> <span class="token operator">*</span>p2 <span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 无法确定？</span>
<span class="token comment">// 当语言无法区分那是一个声明还是一个表达式的时候，我们需要一个超越语言范围的规则，</span>
<span class="token comment">// 该规则会将上述的式子判定为一个『声明』</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<br/>

<h4 id="struct-和-class-的区别"><a href="#struct-和-class-的区别" class="headerlink" title="struct 和 class 的区别"></a>struct 和 class 的区别</h4><p>C++ 引入 class 的重要性（非必要）：class 代表了一种所支持的<code>封装和继承的哲学</code>。</p>
<p>如果 C++ 需要<code>支持现存的 C 程序代码</code>，就不能不支持 struct。</p>
<p>真正的问题不在于我们的声明是否使用了相同的关键词 struct&#x2F;class，而是对于类声明的某种承诺：</p>
<p><code>struct</code> 实现 C 的数据萃取观念。</p>
<p><code>class</code> 实现的是 C++ 的 ADT (Abstract Data Type) 观念。</p>
<p>class 真正特性是由声明的本身来决定的。</p>
<p><strong>如果我们迫切需要一个相当复杂的 C++ class 的某些部分的数据，使它像 C 声明的样子，那么那一部分最好是 抽离出来形成一个独立的 struct 声明，然后让 C++ 与 C 组合（composition）:</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">C_Point</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span> 
    <span class="token keyword">operator</span> <span class="token function">C_Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> _c_point<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
    <span class="token comment">// ...</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    C_Point _c_point<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<br/>

<h3 id="对象的差异"><a href="#对象的差异" class="headerlink" title="对象的差异"></a>对象的差异</h3><p>需要多少内存才能变现一个 class object ? 一般而言：</p>
<p>1、非静态数据成员的总和大小。</p>
<p>2、加上任何由于 <strong>alignment</strong> 需求而填补上去的空间。（<strong>alignment</strong> 就是字节对齐，在 32 位计算机上，alignment 通常为 4 bytes（32位），以使 bus 的 运输量达到最大效率。）</p>
<p>3、加上为了支持 <strong>virtual</strong> 而由内部产生的任何额外负担（overload）。 </p>
<br/>

<h4 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h4><p>一个指针，不管它指向那种数据类型，指针本身所需的内存大小是固定的（32 位机器上是 4 bytes，64 位机器上是 8 bytes），指针类型只会教导编译器如何解释某个特定地址中的内存内容及其大小。</p>
<div class="tabs" id="zooanimal"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="zooanimal-1">class ZooAnimal</button><button type="button" class="tab " data-href="zooanimal-2">ZooAnimal object 内存布局</button></ul><div class="tab-contents"><div class="tab-item-content active" id="zooanimal-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">ZooAnimal</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">ZooAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">ZooAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">int</span> location_<span class="token punctuation">;</span>
    String name_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

ZooAnimal <span class="token function">za</span><span class="token punctuation">(</span><span class="token string">"Zoey"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ZooAnimal<span class="token operator">*</span> pza <span class="token operator">=</span> <span class="token operator">&amp;</span>za<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="zooanimal-2"><p>如果 String 是传统的 8-bytes（包括一个 4 bytes 的 char* 和表示长度的 int ），一个 ZooAnimal 指针将横跨地址空间 1000~1015（4+8+4）,如图：</p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/%E7%8B%AC%E7%AB%8Bclass%E7%9A%84object%E5%B8%83%E5%B1%80%E5%92%8Cpointer%E5%B8%83%E5%B1%80.png"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>

<p>对于一个指向某个地址的 <code>void*</code> 指针，我们并不知道他将涵盖怎样的地址，所以 <strong>不能通过它操作所指的 object</strong>。</p>
<p>对于<strong>转型（cast）</strong>，其实是一种编译器指令，它并不改变一个指针所含的真正地址，<strong>它只影响被指明的内存的大小和内容的解释方式。</strong></p>
<br/>

<h4 id="加上多态之后"><a href="#加上多态之后" class="headerlink" title="加上多态之后"></a>加上多态之后</h4><div class="tabs" id="adding-polymorphism"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="adding-polymorphism-1">class Bear</button><button type="button" class="tab " data-href="adding-polymorphism-2">Bear object 内存布局</button><button type="button" class="tab " data-href="adding-polymorphism-3">Bear* 与 ZooAnimal*</button><button type="button" class="tab " data-href="adding-polymorphism-4">指针支持多态的本质</button></ul><div class="tab-contents"><div class="tab-item-content active" id="adding-polymorphism-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Bear</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">ZooAnimal</span></span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">dance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>

  <span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">enum</span> <span class="token class-name">Dances</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    Dances dances_known<span class="token punctuation">;</span>
    <span class="token keyword">int</span> cell_block<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

Bear <span class="token function">b</span><span class="token punctuation">(</span><span class="token string">"Yogi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Bear <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
Bear <span class="token operator">&amp;</span>rb <span class="token operator">=</span> <span class="token operator">*</span>pb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="adding-polymorphism-2"><p>对于 Bear 的实例 b, 在 32 位机器上，需要 24 bytes [ZooAnimal 的 16 bytes + Bear 所带来的 8 bytes ]，指针 pb 和 引用 rb 需要 4 bytes。</p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/Derived%20class%20%E7%9A%84%20object%20%E5%92%8C%20pointer%20%E5%B8%83%E5%B1%80.png"></div><div class="tab-item-content" id="adding-polymorphism-3"><p>思考：一个派生类指针 Bear *pb 和 一个父类指针 ZooAnimal *pz 有何不同？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Bear b<span class="token punctuation">;</span>
ZooAnimal <span class="token operator">*</span>pz <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
Bear <span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
<span class="token comment">// 它们都指向了 Bear object 的第一个 byte，但是：</span>

<span class="token comment">// pb 所涵盖的地址包含整个 Bear object !!!</span>
<span class="token comment">// pz 只包含 Bear object 中的 ZooAnimal subobject !!!</span>

<span class="token comment">// error: 不合法操作！！!</span>
pz<span class="token operator">-></span>cell_block<span class="token punctuation">;</span>

<span class="token comment">// 可以进行下行转换，[运行时操作,成本较高]</span>
<span class="token comment">// ok</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> Bear <span class="token operator">*</span>pb2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Bear<span class="token operator">*</span> <span class="token operator">></span></span></span><span class="token punctuation">(</span>pz<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  	pb2<span class="token operator">-></span>cell_block<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="adding-polymorphism-4"><p>一个指针或引用之所以支持多态，是因为<strong>它们并不会引发内存中任何 『与类型有关的内存委托操作（type-dependent commitment）』，受到改变的是它们所指向内存的『大小和内容的解释方式』而已。</strong></p>
<p>例如，对于父类指针调用 <code>pz-&gt;Rotate()</code> 时，<code>pz</code> 的类型将决定一下两点：</p>
<ul>
<li>pz 只能调用 ZooAnimal 的 public 接口。</li>
<li>该接口的 access level （Rotate() 是 ZooAnimal 的一个 public member）。</li>
</ul>
<p><code>pz</code> 所指的 <code>object</code> 类型可以决定 <code>Rotate()</code> 所调用的实体，但是调用的是父类（<code>ZooAnimal</code>）的 <code>Rotate()</code> 还是派生类（<code>Bear</code>）的 <code>Rotate()</code> 由 <code>vtpr</code> 指向的 <code>virtual table</code> 决定，且看后续讨论。</p>
<p>再看这么一种情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Bear b<span class="token punctuation">;</span>
ZooAnimal za <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 会引起切割</span>

<span class="token comment">// 调用 ZooAnimal::rotate()</span>
za<span class="token punctuation">.</span><span class="token function">Rotate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>思考：</p>
<p>1、将 <code>Bear</code> 实体完整拷贝给 <code>ZooAnimal</code> 实体去，为什么 <code>za</code> 实体的 <code>vptr</code> 不指向 <code>Bear</code> 的 <code>virtual table</code>?</p>
<p>  编译器确保了如果某一个 <code>object</code> 含有一个或者一个以上的 <code>vptrs</code>，那么 <code>vptrs</code> 的内容不会被 <code>base class object</code> 初始化或改变。</p>
<p>2、为什么 <code>Rotate()</code> 是被 <code>ZooAnimal</code> 实体调用而不是 <code>Bear</code> 实体？</p>
<p>  <code>za</code> 并不是一个 <code>Bear</code> 实体，它只能是 ZooAnimal 实体，面向对象设计不支持对 <code>object</code> 的直接处理，多态不能够实际发挥在 <strong>直接存取 objects</strong> 这件事情上。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Panda</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Bear</span></span> <span class="token punctuation">&#123;</span> 
  <span class="token comment">//... </span>
<span class="token punctuation">&#125;</span>

<span class="token punctuation">&#123;</span>
  ZooAnimal za<span class="token punctuation">;</span>
  ZooAnimal <span class="token operator">*</span>pza<span class="token punctuation">;</span>
  
  Bear b<span class="token punctuation">;</span>
  pza <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
  
  Panda <span class="token operator">*</span>pp <span class="token operator">=</span> <span class="token keyword">new</span> Panda<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>其可能的布局如下：</p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/Object%20Model/ZooAnimal-Bear-Panda.png">

<p>当一个基类对象实例被用来初始化一个派生类对象时，派生类对象会被切割，以塞入较小的 base type 内存中， 编译时期通过这个实例触发 virtual function 调用操作。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>



<h2 id="构造语义学（The-Semantics-of-constructors）"><a href="#构造语义学（The-Semantics-of-constructors）" class="headerlink" title="构造语义学（The Semantics of constructors）"></a>构造语义学（The Semantics of constructors）</h2><p><code>本章主要讲：编译器在哪些情况下，必须为没有声明构造函数的类生成必要的默认构造函数和拷贝构造函数，以及编译器为参数初始化、返回值初始化等做了哪些优化操作。</code></p>
<br/>

<h3 id="Default-Constructor-的建构操作"><a href="#Default-Constructor-的建构操作" class="headerlink" title="Default Constructor 的建构操作"></a>Default Constructor 的建构操作</h3><p><code>对于 C++ 新手常见的误解：</code></p>
<ul>
<li><p>任何 class 如果没有定义默认构造函数（default constructor），就会被合成一个出来？</p>
</li>
<li><p>编译器合成出来的默认构造函数（default constructor） 会明确设定类内每一个类数据成员的默认值？</p>
</li>
</ul>
<p><strong>以上两个观点都不是真的！！！</strong></p>
<br/>

<p>有四种情况会导致一个类的构造函数是 <strong>non-trivial</strong>，使得编译器必须为没有声明构造函数（constructor）的类合成一个 默认构造函数（default constructor），C++ 规范称之为 <strong>隐式必要默认构造函数（implict nontrivial default constructors）</strong>。合成出来只为了满足编译器需要。</p>
<p>在 <strong>合成的默认构造函数（default constructor）</strong> 中，编译器认为 <strong>基类子对象（base class subobjects） 和 成员类对象（member class objects） 是重要的，会初始化它们</strong>。其它 非静态数据成员等初始化操作应该有编码者自行初始化。</p>
<h3 id="编译器必须合成默认构造函数的4种情形"><a href="#编译器必须合成默认构造函数的4种情形" class="headerlink" title="编译器必须合成默认构造函数的4种情形"></a>编译器必须合成默认构造函数的4种情形</h3><div class="tabs" id="必须合成默认构造函数的4种情形"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="必须合成默认构造函数的4种情形-1">A</button><button type="button" class="tab " data-href="必须合成默认构造函数的4种情形-2">B</button><button type="button" class="tab " data-href="必须合成默认构造函数的4种情形-3">C</button><button type="button" class="tab " data-href="必须合成默认构造函数的4种情形-4">D</button></ul><div class="tab-contents"><div class="tab-item-content active" id="必须合成默认构造函数的4种情形-1"><p><strong>1、该类中的成员对象（Member Class Object），带有默认构造函数（Default Constructor）</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  	<span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  	Foo foo<span class="token punctuation">;</span>	<span class="token comment">// 内含</span>
  	<span class="token keyword">char</span><span class="token operator">*</span> str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 编译器的行动是：如果 class A 内含一个及以上的 member class</span>
<span class="token comment">// objects， 那么 class A 的每一个 constructor 必须调用每一个</span>
<span class="token comment">// member classes 的 default constructor.</span>
<span class="token comment">// 扩张后的 dafault constructor</span>
<span class="token class-name">Bar</span><span class="token double-colon punctuation">::</span><span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  foo<span class="token punctuation">.</span><span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 附加上的compiler code</span>
  str <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>				<span class="token comment">// 显式的用户代码</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果存在多个 class member objects要求 constructor 初始化操作，C++ 要求以 { member objects 在 class 中的声明次序 }来调用各个 constructors。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Dopey</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">Dopey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Sneezy</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">Sneezy</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">Sneezy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Bashful</span> <span class="token punctuation">&#123;</span> <span class="token keyword">public</span><span class="token operator">:</span> <span class="token function">Bashful</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SnowWhite</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  	Dopey dopey<span class="token punctuation">;</span>
  	Sneezy sneezy<span class="token punctuation">;</span>
  	Bashful bashful<span class="token punctuation">;</span>
  	<span class="token comment">// ...</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
  	<span class="token keyword">int</span> mumble<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="必须合成默认构造函数的4种情形-2"><p><strong>2、该类派生自带有默认构造函数（Default Constructor）的基类（Base Class）</strong></p></div><div class="tab-item-content" id="必须合成默认构造函数的4种情形-3"><p><strong>3、该类中存在虚函数（Virtual Function）</strong></p></div><div class="tab-item-content" id="必须合成默认构造函数的4种情形-4"><p><strong>4、该类的继承链中，存在虚继承，即该类的基类是虚基类（Virtual Base Class）</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>

<h3 id="Copy-Constructor-的建构操作"><a href="#Copy-Constructor-的建构操作" class="headerlink" title="Copy Constructor 的建构操作"></a>Copy Constructor 的建构操作</h3><p>在此，之前，我们需要知道 <strong>Bitwise Copy</strong> 和 <strong>Memberwise Copy</strong> 的区别（参考自 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d%EF%BC%89%EF%BC%9A">https://stackoverflow.com/questions/42749439/what-is-the-difference-between-memberwise-copy-bitwise-copy-shallow-copy-and-d）：</a></p>
<table>
<thead>
<tr>
<th align="center">Bitwise Copy</th>
<th align="center">Memberwise Copy</th>
</tr>
</thead>
<tbody><tr>
<td align="center">浅拷贝的一种形式，通过 <strong>memcopy</strong> 类似的操作实现 <strong>源对象-&gt;目标对象</strong> 的 <strong>按位拷贝</strong>，<strong>不关联类对象的 构造函数（Constructor）调用。</strong></td>
<td align="center">深拷贝的一种形式，<strong>走访每一个对象成员并且显式地拷贝它们，关联调用它们的构造函数（Constructor）</strong>。</td>
</tr>
<tr>
<td align="center">如果类对象被认为是 <strong>trivial</strong>（具备 bitwise copy semantics），没有自定义 拷贝构造函数或者赋值拷贝操作符，执行的是 Bitwise Copy</td>
<td align="center"></td>
</tr>
</tbody></table>
<br/>

<p>一个 class 在下面四种情况会表现出 <u><strong>非 bitwise copy  semantics</strong></u>：</p>
<div class="tabs" id="应该-memberwise-copy-4种情形"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="应该-memberwise-copy-4种情形-1">成员对象含拷贝构造</button><button type="button" class="tab " data-href="应该-memberwise-copy-4种情形-2">基类存在拷贝构造</button><button type="button" class="tab " data-href="应该-memberwise-copy-4种情形-3">声明了一个或多个虚函数</button><button type="button" class="tab " data-href="应该-memberwise-copy-4种情形-4">继承链上有一个或多个虚基类</button></ul><div class="tab-contents"><div class="tab-item-content active" id="应该-memberwise-copy-4种情形-1"><p>编译器必须将成员对象的拷贝构造调用操作安插在合成的 copy constructor 中。</p></div><div class="tab-item-content" id="应该-memberwise-copy-4种情形-2"><p>编译器必须将基类拷贝构造调用操作安插在合成的 copy constructor 中。</p></div><div class="tab-item-content" id="应该-memberwise-copy-4种情形-3"><p>拷贝操作中，目标对象的 虚函数指针（vptr）必须设定为源对象的 vptr。</p></div><div class="tab-item-content" id="应该-memberwise-copy-4种情形-4"><p>拷贝操作中，目标对象的 虚基类指针（vbptr）必须设定为源对象的 vbptr。</p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>

<h2 id="Data-语义学（The-Semantics-of-Data）"><a href="#Data-语义学（The-Semantics-of-Data）" class="headerlink" title="Data 语义学（The Semantics of Data）"></a>Data 语义学（The Semantics of Data）</h2><p><code>本章主要讲一般的继承和虚拟继承下类成员变量的内存布局情况、编译器如何对类内成员进行存取等。</code></p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p><code>内存地址 a 被称为 n 字节对齐，a 是 n 的倍数（ n 应是2的幂），也可以理解为当被访问的数据长度为 n 字节时，数据地址为 n 字节对齐。如果内存未对齐，称作 misaligned。</code></p>
<p><code>内存指针是对齐的，如果它所指的数据是对齐的。指向聚合数据（aggregate data，如struct或数组）是对齐的，当且仅当它的每个组成数据是对齐的。</code></p>
<div class="tabs" id="字节对齐"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="字节对齐-1">问题引入</button><button type="button" class="tab " data-href="字节对齐-2">为什么要字节对齐</button><button type="button" class="tab " data-href="字节对齐-3">字节对齐原则</button><button type="button" class="tab " data-href="字节对齐-4">继承下的字节对齐</button><button type="button" class="tab " data-href="字节对齐-5">强制字节对齐</button></ul><div class="tab-contents"><div class="tab-item-content active" id="字节对齐-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> id_<span class="token punctuation">;</span>
    <span class="token keyword">char</span> name_<span class="token punctuation">;</span>
    <span class="token keyword">float</span> salary_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

A a<span class="token punctuation">;</span>
<span class="token comment">// sizeof (a) = ?;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="字节对齐-2"><p>《Windows核心编程》里这样说：当CPU访问正确对齐的数据时，它的运行效率最高，当数据大小的数据模数的内存地址是0时，数据是对齐的。例如：WORD值应该是总是从被2除尽的地址开始，而DWORD值应该总是从被4除尽的地址开始，数据对齐不是内存结构的一部分，而是CPU结构的一部分。当CPU试图读取的数值没有正确的对齐时，CPU可以执行两种操作之一：产生一个异常条件；执行多次对齐的内存访问，以便读取完整的未对齐数据，若多次执行内存访问，应用程序的运行速度就会慢。</p></div><div class="tab-item-content" id="字节对齐-3"><p>在系统默认的对齐方式下，每个成员相对于这个结构体变量地址的偏移量正好是该成员类型所占字节的整数倍，且最终占用字节数为成员类型中最大占用字节数的整数倍。例子中，id_ 的偏移量为 0（0 * 4），name_ 的偏移量为4（1 * 4），salary_ 的偏移量为（2 * 4），总共占用12字节，满足成员中最大占用字节数（ float ）的整数倍（3 * 4）。</p></div><div class="tab-item-content" id="字节对齐-4"></div><div class="tab-item-content" id="字节对齐-5"><p>#pragma directive指定对齐的包入（packing）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>push<span class="token punctuation">)</span>  </span><span class="token comment">/* push current alignment to stack */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     </span><span class="token comment">/* set alignment to 1 byte boundary */</span></span>

<span class="token keyword">struct</span> <span class="token class-name">MyPackedData</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> Data1<span class="token punctuation">;</span>
    <span class="token keyword">long</span> Data2<span class="token punctuation">;</span>
    <span class="token keyword">char</span> Data3<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">pack</span><span class="token punctuation">(</span>pop<span class="token punctuation">)</span>   </span><span class="token comment">/* restore original alignment from stack */</span></span>

<span class="token comment">// 这个结构在32位系统的大小为6字节。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>

<br/>

<h2 id="Function-语义学（The-Semantics-of-Function）"><a href="#Function-语义学（The-Semantics-of-Function）" class="headerlink" title="Function 语义学（The Semantics of Function）"></a>Function 语义学（The Semantics of Function）</h2><p><code>本章主要讲编译器如何让类成员函数和普通函数一样具有相同的使用效率、编译器为类成员函数做了哪些优化、编译器如何针对单一继承、多重继承和虚继承下的虚函数的区分处理、讨论指向一个类成员函数指针和一个类成员虚函数指针以及多重继承下的类成员函数指针的多态性。</code></p>
<br/>

<h2 id="构造、析构、拷贝语义学（Semantics-of-Construction-Destruction-Copy）"><a href="#构造、析构、拷贝语义学（Semantics-of-Construction-Destruction-Copy）" class="headerlink" title="构造、析构、拷贝语义学（Semantics of Construction, Destruction, Copy）"></a>构造、析构、拷贝语义学（Semantics of Construction, Destruction, Copy）</h2><p><code>本章主要介绍一般无继承情况下，初始化列表在构造函数的扩展方式。介绍多继承、虚继承下，继承链的构造顺序、析构顺序，虚函数表指针 vptr 的设定时机。讨论何时应该设计一个拷贝赋值操作（copy assignment operator）</code></p>
<h3 id="构造语义学"><a href="#构造语义学" class="headerlink" title="构造语义学"></a>构造语义学</h3><p>无继承关系下，C++ 的构造情况：</p>
<div class="tabs" id="无继承关系下的构造情况"><ul class="nav-tabs"><button type="button" class="tab  active" data-href="无继承关系下的构造情况-1">POD 类型</button><button type="button" class="tab " data-href="无继承关系下的构造情况-2">抽象数据类型</button><button type="button" class="tab " data-href="无继承关系下的构造情况-3">虚析构定义视情况而定</button></ul><div class="tab-contents"><div class="tab-item-content active" id="无继承关系下的构造情况-1"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 会被贴上 POD 的标签</span>
<span class="token keyword">struct</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 行为如同 C 一样, global 被视为 临时性定义，</span>
<span class="token comment">// 没有明确定义，这些全局示例会被连接器折叠起来，只留下单独一个实体，</span>
<span class="token comment">// 被放在程序（data segment 中一个特别保留给未初始化的 global 对象使用）</span>
<span class="token comment">// 这个空间叫 BSS (Block Started by Symbol)</span>
Point p<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="无继承关系下的构造情况-2"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 显式初始化列表</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Point</span><span class="token punctuation">(</span><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token keyword">float</span> z <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">)</span> 
        <span class="token operator">:</span> <span class="token function">x_</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    	  <span class="token function">y_</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">float</span> x_<span class="token punctuation">,</span> y_<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 可以定义实话为 local object </span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ...</span>
    Point local<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 编译器层面会有一个优化机制来识别 inline constructors, 提供一个 member-by-member 的常量指定操作</span>
<span class="token comment">// 被附加上 Point 的默认构造函数内联扩展</span>
<span class="token punctuation">&#123;</span>
    Point local<span class="token punctuation">;</span>
    local<span class="token punctuation">.</span>x_ <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>
    local<span class="token punctuation">.</span>y_ <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 如果在堆上分配一个 Point 实例对象</span>
<span class="token punctuation">&#123;</span>
    Point <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> Point<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">//  C++ 伪代码</span>
<span class="token punctuation">&#123;</span>
    Point <span class="token operator">*</span> heap <span class="token operator">=</span> <span class="token function">__new</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>Point<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>heap <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        heap<span class="token operator">-></span><span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 因为没有明确地提供一个 析构 函数实体</span>
<span class="token comment">// 不会调用析构</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">delete</span> heap<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><div class="tab-item-content" id="无继承关系下的构造情况-3"><p>因为一个类如果定义了虚函数，则每个实例化对象就会要多拥有 一个指向 虚函数表的 vptr，产生膨胀，例子中 Point 的构造函数也会被编译器处理成：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Point<span class="token operator">*</span> <span class="token class-name">Point</span><span class="token double-colon punctuation">::</span><span class="token function">Point</span> <span class="token punctuation">(</span>Point <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 设定 object 的 virtual table pointer （vptr）</span>
    <span class="token keyword">this</span><span class="token operator">-></span>__vptr_Point <span class="token operator">=</span> __vtpr_point<span class="token punctuation">;</span>
    
    <span class="token keyword">this</span><span class="token operator">-></span>x_ <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token operator">-></span>y_ <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>



<p>继承体系下，构造的顺序是先从继承链上的最上层的基类依次往下调用派生类的构造函数来完成。</p>
<br/>

<h3 id="复制语义学"><a href="#复制语义学" class="headerlink" title="复制语义学"></a>复制语义学</h3><p>当我们设计一个 class，我们可以指定种关于复制构造的选择：</p>
<p><code>1、什么都不做，使用默认复制构造。</code></p>
<p><code>2、提供一个显式的 拷贝赋值 operator。</code></p>
<p><code>3、明确拒绝对象给另一个对象的复制构造行为。</code></p>
<p>如果一个类已经有了浅拷贝（bitwise copy）语意，隐式拷贝赋值操作符（copy assignment operator）被视为无效，所以一个类会在如下四种情况表现出深拷贝（memberwise copy）语意：</p>
<p><code>1、当一个 class 内带一个 成员对象，成员对象所属类本身有一个拷贝赋值操作符时。</code></p>
<p><code>2、当一个 class 的基类有一个拷贝赋值操作符时。</code></p>
<p><code>3、当一个 class 声明了任何的 virtual functions（一定不能拷贝右端 class 对象的 vptr 地址，因为可能是一个 继承类对象）。</code></p>
<p><code>4、当一个 class 继承自一个虚基类时（不论 虚基类有没有 copy operator）。</code></p>
<p><strong>尽量不要允许一个虚基类的拷贝操作！！！</strong></p>
<br/>

<h3 id="析构语义学"><a href="#析构语义学" class="headerlink" title="析构语义学"></a>析构语义学</h3><p>析构函数的执行顺序和构造函数的相反：</p>
<p><code>1、当前 class 实例化对象的析构首先被执行。</code></p>
<p><code>2、如果 class 中拥有多个成员对象，成员对象们拥有析构函数，那么它们会以其声明顺序的相反顺序被调用。</code></p>
<p><code>3、如果 class 实例化对象内带一个 vptr，则会被重新设定，指向适当的基类 虚函数表。</code></p>
<p><code>读者注：3说明了为什么基类定义了虚析构函数，在形如 Base* p = new Derived() 时， delete p； 后可以调用到派生类的析构函数，因为 vptr 会被依次调整，找到虚函数表中，各个继承链中虚析构函数来调用。只要基类定义了虚析构函数，继承类的析构函数不管加不加 virtual 关键字，都是虚函数，都会出现在 vtable 中。</code></p>
<br/>

<h2 id="执行期语义学（Runtime-Semantics）"><a href="#执行期语义学（Runtime-Semantics）" class="headerlink" title="执行期语义学（Runtime Semantics）"></a>执行期语义学（Runtime Semantics）</h2><p><code>本章主要讨论程序执行期发生的转换、</code></p>
<br/>

<h2 id="站在对象模型的类端（On-the-Cusp-of-the-Object-Model）"><a href="#站在对象模型的类端（On-the-Cusp-of-the-Object-Model）" class="headerlink" title="站在对象模型的类端（On the Cusp of the Object Model）"></a>站在对象模型的类端（On the Cusp of the Object Model）</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">JoyChen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/08/C++%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20C++%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/">http://example.com/2021/10/08/C++%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2%20C++%20%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">JoyChen's 知识星球</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/">C++ 对象模型</a><a class="post-meta__tags" href="/tags/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97/">拆书系列</a></div><div class="post_share"><div class="social-share" data-image="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/a/a1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/13/Go/go%E5%9F%BA%E7%A1%80/" title="go 基础"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go 基础</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/22/Job%20Relative/%E4%B8%80%E7%A7%8DPDF%E5%88%86%E6%A0%8F%E8%AF%86%E5%88%AB%E7%9A%84%E6%96%B9%E6%B3%95/" title="一种PDF分栏识别算法实现"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-3.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一种PDF分栏识别算法实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/23/SQL/%E3%80%8AAdvance%20MySQL%E3%80%8B%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%86%E5%8F%B2/" title="拆书系列之《高性能 MySQL》 MySQL 架构与历史"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-14.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-23</div><div class="title">拆书系列之《高性能 MySQL》 MySQL 架构与历史</div></div></a></div><div><a href="/2021/07/08/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%88functors%EF%BC%89/" title="拆书系列之《STL 源码剖析》仿函数（functors）"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-11.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="title">拆书系列之《STL 源码剖析》仿函数（functors）</div></div></a></div><div><a href="/2021/06/19/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88associative%20containers%EF%BC%89/" title="拆书系列之《STL源码剖析》关联式容器（associative containers）"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-13.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-19</div><div class="title">拆书系列之《STL源码剖析》关联式容器（associative containers）</div></div></a></div><div><a href="/2021/06/08/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E6%A6%82%E8%BF%B0/" title="拆书系列之《STL 源码剖析》概述"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-12.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-08</div><div class="title">拆书系列之《STL 源码剖析》概述</div></div></a></div><div><a href="/2021/06/19/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8%EF%BC%88allocator%EF%BC%89/" title="拆书系列之《STL 源码剖析》空间配置器（allocator）"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-8.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-19</div><div class="title">拆书系列之《STL 源码剖析》空间配置器（allocator）</div></div></a></div><div><a href="/2021/06/19/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E7%AE%97%E6%B3%95%EF%BC%88algorithms%EF%BC%89/" title="拆书系列之《STL源码剖析》算法（Algorithm）"><img class="cover" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-19</div><div class="title">拆书系列之《STL源码剖析》算法（Algorithm）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">JoyChen</div><div class="author-info__description">If you haven't found it yet Keep looking Don't settle</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JoyChenNo1"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/JoyChenNo1" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:joychenisno1@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8A%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B"><span class="toc-number">1.</span> <span class="toc-text">拆书系列之《深度探索 C++ 对象模型》</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%EF%BC%88Object-Lessons%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">关于对象（Object Lessons）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E4%B8%8A%E5%B0%81%E8%A3%85%E5%90%8E%E7%9A%84%E5%B8%83%E5%B1%80%E6%88%90%E6%9C%AC"><span class="toc-number">1.1.1.</span> <span class="toc-text">加上封装后的布局成本</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F%EF%BC%88The-C-Object-Model%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">C++ 对象模式（The C++ Object Model）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%88The-C-Object-Model%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">C++ 对象模型（The C++ Object Model）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E4%B8%8A%E7%BB%A7%E6%89%BF%E7%9A%84-C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">加上继承的 C++ 对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">对象模型如何影响程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D%E6%89%80%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">关键词所带来的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">struct 和 class 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.2.5.</span> <span class="toc-text">对象的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">指针类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E4%B8%8A%E5%A4%9A%E6%80%81%E4%B9%8B%E5%90%8E"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">加上多态之后</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%AF%AD%E4%B9%89%E5%AD%A6%EF%BC%88The-Semantics-of-constructors%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">构造语义学（The Semantics of constructors）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Default-Constructor-%E7%9A%84%E5%BB%BA%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.</span> <span class="toc-text">Default Constructor 的建构操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%BF%85%E9%A1%BB%E5%90%88%E6%88%90%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%844%E7%A7%8D%E6%83%85%E5%BD%A2"><span class="toc-number">1.3.2.</span> <span class="toc-text">编译器必须合成默认构造函数的4种情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-Constructor-%E7%9A%84%E5%BB%BA%E6%9E%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.3.</span> <span class="toc-text">Copy Constructor 的建构操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-%E8%AF%AD%E4%B9%89%E5%AD%A6%EF%BC%88The-Semantics-of-Data%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">Data 语义学（The Semantics of Data）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-number">1.4.1.</span> <span class="toc-text">字节对齐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-%E8%AF%AD%E4%B9%89%E5%AD%A6%EF%BC%88The-Semantics-of-Function%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">Function 语义学（The Semantics of Function）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E6%8B%B7%E8%B4%9D%E8%AF%AD%E4%B9%89%E5%AD%A6%EF%BC%88Semantics-of-Construction-Destruction-Copy%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">构造、析构、拷贝语义学（Semantics of Construction, Destruction, Copy）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="toc-number">1.6.1.</span> <span class="toc-text">构造语义学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="toc-number">1.6.2.</span> <span class="toc-text">复制语义学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E8%AF%AD%E4%B9%89%E5%AD%A6"><span class="toc-number">1.6.3.</span> <span class="toc-text">析构语义学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%9C%9F%E8%AF%AD%E4%B9%89%E5%AD%A6%EF%BC%88Runtime-Semantics%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">执行期语义学（Runtime Semantics）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%99%E5%9C%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%B1%BB%E7%AB%AF%EF%BC%88On-the-Cusp-of-the-Object-Model%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">站在对象模型的类端（On the Cusp of the Object Model）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/14/%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/Docker%20build/" title="Docker 基础镜像构建示例"><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/material-2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Docker 基础镜像构建示例"/></a><div class="content"><a class="title" href="/2024/01/14/%E5%B7%A5%E7%A8%8B%E6%9E%84%E5%BB%BA/Docker%20build/" title="Docker 基础镜像构建示例">Docker 基础镜像构建示例</a><time datetime="2024-01-14T12:08:00.000Z" title="发表于 2024-01-14 20:08:00">2024-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/15/Go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Context/" title="Go 并发编程-Context"><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/a/a7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 并发编程-Context"/></a><div class="content"><a class="title" href="/2023/12/15/Go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Context/" title="Go 并发编程-Context">Go 并发编程-Context</a><time datetime="2023-12-15T09:08:00.000Z" title="发表于 2023-12-15 17:08:00">2023-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/15/Go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Cond/" title="Go 并发编程-Condition"><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/a/a6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go 并发编程-Condition"/></a><div class="content"><a class="title" href="/2023/12/15/Go/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-Cond/" title="Go 并发编程-Condition">Go 并发编程-Condition</a><time datetime="2023-12-15T09:08:00.000Z" title="发表于 2023-12-15 17:08:00">2023-12-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/img/random/a/a1.png')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By JoyChen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script src="/js/tag-common/index.js"></script><!-- hexo injector body_end end --></body></html>