<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head>
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.6 -->
    <script>
        window.materialVersion = "1.5.6"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0',
            '1.5.2',
            '1.5.5'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">













    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            拆书系列之《STL源码剖析》序列式容器（sequence containers） | 
        
        进阶之路
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" href="/img/favicon.png">

    <meta name="format-detection" content="telephone=no"/>
    <meta name="description" itemprop="description" content="">
    <meta name="keywords" content=",STL container">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?Dp7k2X9uh6CgQx67yceHxQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?CC5Yjp011Bf1QgvH2to+Cw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/tomorrow-night-bright.min.css?POjR8UWU/nzYlm7nv2wGjQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "monaco", Helvetica, "PingFang SC", "Hiragino Sans GB", Arial, sans-serif, monaco;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #333332 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #333332 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #333332 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #2a2d37;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="进阶之路">
    <meta name="msapplication-starturl" content="http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="进阶之路">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="拆书系列之《STL源码剖析》序列式容器（sequence containers） | 进阶之路">
    <meta property="og:image" content="/img/favicon.png">
    <meta property="og:description" content="">
    <meta property="og:article:tag" content="STL container"> 

    
        <meta property="article:published_time" content="Sun Jun 06 2021 23:43:09 GMT+0800">
        <meta property="article:modified_time" content="Mon Jun 28 2021 00:18:43 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html" />
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html",
    "headline": "拆书系列之《STL源码剖析》序列式容器（sequence containers）",
    "datePublished": "Sun Jun 06 2021 23:43:09 GMT+0800",
    "dateModified": "Mon Jun 28 2021 00:18:43 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "Joy Chen",
        "image": {
            "@type": "ImageObject",
            "url": "/img/me.png"
        },
        "description": "永远怀着一颗学徒的心"
    },
    "publisher": {
        "@type": "Organization",
        "name": "进阶之路",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/favicon.png"
        }
    },
    "keywords": ",STL container",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

<meta name="generator" content="Hexo 5.4.0"></head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span id="MD-burger-id" class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence-containers%EF%BC%89"><span class="post-toc-number">1.</span> <span class="post-toc-text">《STL源码剖析》序列式容器（sequence containers）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#vector"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">vector</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector-%E4%BB%A3%E7%A0%81%E6%91%98%E8%A6%81%EF%BC%88GCC-%E7%89%88%E6%9C%AC%EF%BC%89"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">vector 代码摘要（GCC 版本）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector-%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">vector 的迭代器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">vector 的数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">vector 初始化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector-%E4%B9%8B-insert"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">vector 之 insert()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#vector-%E4%B9%8B-erase"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">vector 之 erase()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#list"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">list</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E8%8A%82%E7%82%B9"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">list 节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">list 迭代器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">list 数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E4%B9%8B-unique"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">list 之 unique()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E4%B9%8B-erase"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">list 之 erase()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#transfer"><span class="post-toc-number">1.2.6.</span> <span class="post-toc-text">transfer()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E4%B9%8B-splice"><span class="post-toc-number">1.2.7.</span> <span class="post-toc-text">list 之 splice()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E4%B9%8B-merge"><span class="post-toc-number">1.2.8.</span> <span class="post-toc-text">list 之 merge()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E4%B9%8B-reverse"><span class="post-toc-number">1.2.9.</span> <span class="post-toc-text">list 之 reverse()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E4%B9%8B-sort"><span class="post-toc-number">1.2.10.</span> <span class="post-toc-text">list 之 sort()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#deque"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">deque</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">deque 迭代器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E5%88%9B%E5%BB%BA"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">deque 创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-push-back"><span class="post-toc-number">1.3.3.</span> <span class="post-toc-text">deque 之 push_back()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-pop-back"><span class="post-toc-number">1.3.4.</span> <span class="post-toc-text">deque 之 pop_back()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-push-front"><span class="post-toc-number">1.3.5.</span> <span class="post-toc-text">deque 之 push_front()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-pop-front"><span class="post-toc-number">1.3.6.</span> <span class="post-toc-text">deque 之 pop_front()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%87%8D%E6%96%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%8E%A7%E5%99%A8"><span class="post-toc-number">1.3.7.</span> <span class="post-toc-text">重新配置中控器</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-insert"><span class="post-toc-number">1.3.8.</span> <span class="post-toc-text">deque 之 insert()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-erase"><span class="post-toc-number">1.3.9.</span> <span class="post-toc-text">deque 之 erase()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#deque-%E4%B9%8B-clear"><span class="post-toc-number">1.3.10.</span> <span class="post-toc-text">deque 之 clear()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#stack"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">stack</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#queue"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">queue</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#heap"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">heap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#push-heap"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">push_heap()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#pop-heap"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">pop_heap()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#sort-heap"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">sort_heap()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#make-heap"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">make_heap()</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#priority-queue"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">priority_queue</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#slist"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">slist</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#slist-%E7%9A%84%E8%8A%82%E7%82%B9%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="post-toc-number">1.8.1.</span> <span class="post-toc-text">slist 的节点和迭代器数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#slist-%E4%B9%8B-%E6%96%B0%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BA"><span class="post-toc-number">1.8.2.</span> <span class="post-toc-text">slist 之 新节点创建</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#list-%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="post-toc-number">1.8.3.</span> <span class="post-toc-text">list 其他方法</span></a></li></ol></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--6dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                拆书系列之《STL源码剖析》序列式容器（sequence containers）
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/me.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>Joy Chen</strong>
        <span>6月 06, 2021</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-none-link" href="/tags/STL-container/" rel="tag">STL container</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=拆书系列之《STL源码剖析》序列式容器（sequence containers）&url=http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html&via=Joy Chen" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    
        <a class="post_share-link" href="https://www.linkedin.com/shareArticle?mini=true&url=http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html&title=拆书系列之《STL源码剖析》序列式容器（sequence containers）" target="_blank">
            <li class="mdl-menu__item">
                分享到 LinkedIn
            </li>
        </a>
    

    <!-- Share QQ -->
    
        <a class="post_share-link" href="http://connect.qq.com/widget/shareqq/index.html?site=进阶之路&title=拆书系列之《STL源码剖析》序列式容器（sequence containers）&summary=&pics=http://example.com/img/favicon.png&url=http://example.com/2021/06/06/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8%EF%BC%88sequence%20containers%EF%BC%89/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 QQ
            </li>
        </a>
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <h1 id="《STL源码剖析》序列式容器（sequence-containers）"><a href="#《STL源码剖析》序列式容器（sequence-containers）" class="headerlink" title="《STL源码剖析》序列式容器（sequence containers）"></a>《STL源码剖析》序列式容器（sequence containers）</h1><p><code>参考自《STL 源码剖析》-侯捷著。</code></p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/%E5%BA%8F%E5%88%97%E5%BC%8F%E5%AE%B9%E5%99%A8.png">

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>vector 的实现技术，关键在于其对大小的控制和重新配置时到的数据移动效率。</code></p>
<br/>

<h3 id="vector-代码摘要（GCC-版本）"><a href="#vector-代码摘要（GCC-版本）" class="headerlink" title="vector 代码摘要（GCC 版本）"></a>vector 代码摘要（GCC 版本）</h3><p><code>stl_vector.h 定义的 vector 会调用到 vector.tcc 里的模板方法，基本以如 _M_xxx_xxx_xxx() 命名。</code></p>
<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;
class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; &#123;
public:
    typedef _Tp                                                                        value_type;
    typedef typename _Base::pointer                 pointer;
    typedef typename _Alloc_traits::const_pointer  const_pointer;
    typedef typename _Alloc_traits::reference       eference;
    typedef typename _Alloc_traits::const_reference    const_reference;
    typedef __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;
    typedef __gnu_cxx::__normal_iterator&lt;const_pointer, vector&gt; const_iterator;
    typedef std::reverse_iterator&lt;const_iterator&gt;  const_reverse_iterator;
    typedef std::reverse_iterator&lt;iterator&gt;        reverse_iterator;
    typedef size_t                          size_type;
    typedef ptrdiff_t              difference_type;
    typedef _Alloc                                                                allocator_type;
  // ...
&#125;;
</code></pre>
</blockquote>
<br/>

<br/>

<h3 id="vector-的迭代器"><a href="#vector-的迭代器" class="headerlink" title="vector 的迭代器"></a>vector 的迭代器</h3><p>普通指针<strong>具备随机存取</strong>的能力。</p>
<blockquote>
<pre><code class="cpp">typedef typename _Base::pointer                       pointer;
typedef __gnu_cxx::__normal_iterator&lt;pointer, vector&gt; iterator;
</code></pre>
</blockquote>
<br/>

<h3 id="vector-的数据结构"><a href="#vector-的数据结构" class="headerlink" title="vector 的数据结构"></a>vector 的数据结构</h3><blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Alloc&gt;
struct _Vector_base &#123;
  //...
  struct _Vector_impl_data &#123;
    pointer _M_start;     // 表示目前使用空间的头
    pointer _M_finish;    // 表示目前使用空间的尾
    pointer _M_end_of_storage;    // 表示目前可用空间的尾
  &#125;;
&#125;;
struct _Vector_impl : public _Tp_alloc_type, public _Vector_impl_data &#123;
 // ...
&#125;

public:
    _Vector_impl _M_impl;
protected:
    void _M_create_storage(size_t __n) &#123;
      this-&gt;_M_impl._M_start = this-&gt;_M_allocate(__n);
      this-&gt;_M_impl._M_finish = this-&gt;_M_impl._M_start;
      this-&gt;_M_impl._M_end_of_storage = this-&gt;_M_impl._M_start + __n;
    &#125;
&#125;;
</code></pre>
</blockquote>
<p>有了<code>_M_start</code> <code>_M_finish</code> <code>_M_end_of_storage</code>这三个迭代器，可以轻松提供 <code>begin()</code>、 <code>end()</code> 、<code>size()</code> 、<code>capacity()</code>、 <code>empty()</code>、 <code>operator[]</code> 、<code>front()</code>、<code>back()</code>接口。</p>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/vector.png">

<p><br/><br/></p>
<h3 id="vector-初始化"><a href="#vector-初始化" class="headerlink" title="vector 初始化"></a>vector 初始化</h3><blockquote>
<pre><code class="cpp"> // Called by the first initialize_dispatch above and by the
// vector(n,value,a) constructor.
// 填充并予以初始化
void _M_fill_initialize(size_type __n, const value_type&amp; __value) &#123;
    this-&gt;_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value,
                                    _M_get_Tp_allocator());
&#125;

template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;
inline _ForwardIterator
uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp&amp; __x) &#123;
    typedef typename iterator_traits&lt;_ForwardIterator&gt;::value_type
       _ValueType;
       // Trivial types can have deleted assignment, so using std::fill
      // would be ill-formed. Require assignability before using std::fill:
      const bool __assignable = is_copy_assignable&lt;_ValueType&gt;::value;
      // 配置后填充
      return __uninitialized_fill_n&lt;__is_trivial(_ValueType) &amp;&amp; __assignable&gt;::
      __uninit_fill_n(__first, __n, __x);
  &#125;

//针对 trivial constructor 的特化版本，调用 std::fill_n
template&lt;&gt;
struct __uninitialized_fill_n&lt;true&gt; &#123;
  template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;
    static _ForwardIterator
    __uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp&amp; __x) &#123; 
      return std::fill_n(__first, __n, __x); &#125;
   &#125;;

//针对 non trivial constructor 的特化版本，调用 ::new
template&lt;bool _TrivialValueType&gt;
struct __uninitialized_fill_n &#123;
  template&lt;typename _ForwardIterator, typename _Size, typename _Tp&gt;
  static _ForwardIterator
    __uninit_fill_n(_ForwardIterator __first, _Size __n,
                   const _Tp&amp; __x) &#123;
       _ForwardIterator __cur = __first;
        __try &#123;
          for (; __n &gt; 0; --__n, (void) ++__cur)
            std::_Construct(std::__addressof(*__cur), __x);
          return __cur;
        &#125;
        __catch(...) &#123;
          std::_Destroy(__first, __cur);
          __throw_exception_again;
        &#125;
     &#125;
   &#125;;
</code></pre>
</blockquote>
<br/>

<br/>

<h3 id="vector-之-insert"><a href="#vector-之-insert" class="headerlink" title="vector 之 insert()"></a>vector 之 insert()</h3><blockquote>
<pre><code class="cpp">void push_back(const value_type&amp; __x) &#123;
  // 还有备用空间
  if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage) &#123;
     _GLIBCXX_ASAN_ANNOTATE_GROW(1);
     _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,
                              __x);
     ++this-&gt;_M_impl._M_finish;
     _GLIBCXX_ASAN_ANNOTATE_GREW(1);
  &#125;
  // 无备用空间
  else
       _M_realloc_insert(end(), __x);
&#125;

// _M_realloc_insert
template&lt;typename _Tp, typename _Alloc&gt;
template&lt;typename... _Args&gt;
void vector&lt;_Tp, _Alloc&gt;:: _M_realloc_insert(iterator __position, _Args&amp;&amp;... __args)
&#123;
      const size_type __len = _M_check_len(size_type(1), &quot;vector::_M_realloc_insert&quot;);
      pointer __old_start = this-&gt;_M_impl._M_start;
      pointer __old_finish = this-&gt;_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this-&gt;_M_allocate(__len));
      pointer __new_finish(__new_start);
      __try &#123;
        // 配置大小为原来的2倍
        _Alloc_traits::construct(this-&gt;_M_impl,
                                 __new_start + __elems_before,
                                 std::forward&lt;_Args&gt;(__args)...);
        __new_finish = pointer();

        if _GLIBCXX17_CONSTEXPR (_S_use_relocate()) &#123;
          __new_finish = _S_relocate(__old_start, __position.base(),
                                     __new_start, _M_get_Tp_allocator());

          ++__new_finish;

          __new_finish = _S_relocate(__position.base(), __old_finish,
                                     __new_finish, _M_get_Tp_allocator());
        &#125; else &#123;
          // 将原来 vector 的内容拷到新的 vector
          // std::__uninitialized_move_if_noexcept_a() 最终会调用到
          // std::uninitialized_copy()
          __new_finish = std::__uninitialized_move_if_noexcept_a (__old_start,                                                        __position.base(), __new_start, _M_get_Tp_allocator());

          ++__new_finish;

          __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(),                                     __old_finish,  __new_finish, _M_get_Tp_allocator());
        &#125;
      &#125;
      __catch(...) &#123;
        if (!__new_finish)
          _Alloc_traits::destroy(this-&gt;_M_impl,  __new_start + __elems_before);
        else
          std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
        _M_deallocate(__new_start, __len);
        __throw_exception_again;
      &#125;
      // 析构并释放原 vector
      if _GLIBCXX17_CONSTEXPR (!_S_use_relocate())
        std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      _GLIBCXX_ASAN_ANNOTATE_REINIT;
      _M_deallocate(__old_start, this-&gt;_M_impl._M_end_of_storage - __old_start);
      // 调整迭代器，指向新的 vector
      this-&gt;_M_impl._M_start = __new_start;
      this-&gt;_M_impl._M_finish = __new_finish;
      this-&gt;_M_impl._M_end_of_storage = __new_start + __len;
&#125;
</code></pre>
</blockquote>
<blockquote>
<pre><code class="cpp">/**
*  @brief  Inserts given rvalue into %vector before specified iterator.
*  @param  __position  A const_iterator into the %vector.
*  @param  __x  Data to be inserted.
*  @return  An iterator that points to the inserted data.
*
*  This function will insert a copy of the given rvalue before
*  the specified location.  Note that this kind of operation
*  could be expensive for a %vector and if it is frequently
*  used the user should consider using std::list.
*/
iterator insert(const_iterator __position, value_type&amp;&amp; __x) &#123; 
  return _M_insert_rval(__position, std::move(__x)); 
&#125;

template&lt;typename _Tp, typename _Alloc&gt;
auto vector&lt;_Tp, _Alloc&gt;::
    _M_insert_rval(const_iterator __position, value_type&amp;&amp; __v) -&gt; iterator &#123;
      const auto __n = __position - cbegin();
      if (this-&gt;_M_impl._M_finish != this-&gt;_M_impl._M_end_of_storage)
        if (__position == cend()) &#123;
            _GLIBCXX_ASAN_ANNOTATE_GROW(1);
            _Alloc_traits::construct(this-&gt;_M_impl, this-&gt;_M_impl._M_finish,
                   std::move(__v));
            ++this-&gt;_M_impl._M_finish;
            _GLIBCXX_ASAN_ANNOTATE_GREW(1);
          &#125;
        else
          _M_insert_aux(begin() + __n, std::move(__v));
      else
        _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this-&gt;_M_impl._M_start + __n);
 &#125;


/** @file bits/vector.tcc
 *  This is an internal header file, included by other library headers.
 *  Do not attempt to use it directly. @headername&#123;vector&#125;
 */

template&lt;typename _Alloc&gt;
void vector&lt;bool, _Alloc&gt;::_M_insert_aux(iterator __position, bool __x) &#123;
  if (this-&gt;_M_impl._M_finish._M_p != this-&gt;_M_impl._M_end_addr()) &#123;
    std::copy_backward(__position, this-&gt;_M_impl._M_finish, 
                       this-&gt;_M_impl._M_finish + 1);
    *__position = __x;
    ++this-&gt;_M_impl._M_finish;
  &#125; else &#123;
    const size_type __len =
      _M_check_len(size_type(1), &quot;vector&lt;bool&gt;::_M_insert_aux&quot;);
    _Bit_pointer __q = this-&gt;_M_allocate(__len);
    iterator __start(std::__addressof(*__q), 0);
    iterator __i = _M_copy_aligned(begin(), __position, __start);
    *__i++ = __x;
    iterator __finish = std::copy(__position, end(), __i);
    this-&gt;_M_deallocate();
    this-&gt;_M_impl._M_end_of_storage = __q + _S_nword(__len);
    this-&gt;_M_impl._M_start = __start;
    this-&gt;_M_impl._M_finish = __finish;
  &#125;
&#125;
</code></pre>
</blockquote>
<blockquote>
<pre><code class="cpp">iterator insert(const_iterator __position, initializer_list&lt;value_type&gt; __l) &#123;
      auto __offset = __position - cbegin();
      _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
                      std::random_access_iterator_tag());
      return begin() + __offset;
&#125;


template&lt;typename _Tp, typename _Alloc&gt;
template&lt;typename _ForwardIterator&gt;
void vector&lt;_Tp, _Alloc&gt;::_M_range_insert(iterator __position, 
     _ForwardIterator __first,                                                           _ForwardIterator __last,  std::forward_iterator_tag) &#123;
    if (__first != __last) &#123;
    const size_type __n = std::distance(__first, __last);
    // 备用空间 &gt;= 新增元素个数
    if (size_type(this-&gt;_M_impl._M_end_of_storage
                     - this-&gt;_M_impl._M_finish) &gt;= __n) &#123;
         // 计算插入点之后的现有元素个数
      const size_type __elems_after = end() - __position;
      pointer __old_finish(this-&gt;_M_impl._M_finish);
      // 插入点之后现有的元素个数 &gt; 新增元素个数
      if (__elems_after &gt; __n) &#123;
        _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
        std::__uninitialized_move_a(this-&gt;_M_impl._M_finish - __n,
                                    this-&gt;_M_impl._M_finish,
                                    this-&gt;_M_impl._M_finish,
                                    _M_get_Tp_allocator());
        this-&gt;_M_impl._M_finish += __n; // 将 vector 尾端标记后移
        _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
        _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                                __old_finish - __n, __old_finish);
        std::copy(__first, __last, __position); // 插入点开始插入新值
      &#125; else &#123;
        // 插入点之后现有的元素个数 &lt;= 新增元素个数
        _ForwardIterator __mid = __first;
        std::advance(__mid, __elems_after);
        _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
        std::__uninitialized_copy_a(__mid, __last,
                                    this-&gt;_M_impl._M_finish,
                                    _M_get_Tp_allocator());
        this-&gt;_M_impl._M_finish += __n - __elems_after;
        _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
        std::__uninitialized_move_a(__position.base(),
                                    __old_finish,
                                    this-&gt;_M_impl._M_finish,
                                    _M_get_Tp_allocator());
        this-&gt;_M_impl._M_finish += __elems_after;
        _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
        std::copy(__first, __mid, __position);
      &#125;
     &#125; else &#123;
      // 配置新的 vector 空间
      const size_type __len = _M_check_len(__n, &quot;vector::_M_range_insert&quot;);
      pointer __new_start(this-&gt;_M_allocate(__len));
      pointer __new_finish(__new_start);
      __try &#123;
          // 1、先将旧 vector 的插入点之前的元素 copy 到新空间
          __new_finish = std::__uninitialized_move_if_noexcept_a
            (this-&gt;_M_impl._M_start, __position.base(),
             __new_start, _M_get_Tp_allocator());

            // 2、将新增元素 copy 到新空间
          __new_finish = std::__uninitialized_copy_a(__first, __last,
                  __new_finish,
                  _M_get_Tp_allocator());
          // 3、将旧 vector 的插入点之后的元素 copy 到新空间
          __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(),                                                                                             this-&gt;_M_impl._M_finish,
                                              __new_finish, _M_get_Tp_allocator());
      &#125;
      __catch(...) &#123;
          std::_Destroy(__new_start, __new_finish,
            _M_get_Tp_allocator());
          _M_deallocate(__new_start, __len);
          __throw_exception_again;
      &#125;
      // 清除释放旧的 vector
      std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,
              _M_get_Tp_allocator());
      _GLIBCXX_ASAN_ANNOTATE_REINIT;
      _M_deallocate(this-&gt;_M_impl._M_start,
              this-&gt;_M_impl._M_end_of_storage
              - this-&gt;_M_impl._M_start);
      // 调整迭代器，指向新的 vector
      this-&gt;_M_impl._M_start = __new_start;
      this-&gt;_M_impl._M_finish = __new_finish;
      this-&gt;_M_impl._M_end_of_storage = __new_start + __len;
      &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Alloc&gt;
void vector&lt;_Tp, _Alloc&gt;::
    _M_fill_insert(iterator __position, size_type __n, const value_type&amp; __x) &#123;
  if (__n != 0) &#123;
       // 备用空间 &gt;= 新增元素个数
      if (size_type(this-&gt;_M_impl._M_end_of_storage - this-&gt;_M_impl._M_finish) 
        &gt;= __n) &#123;
      _Temporary_value __tmp(this, __x);
      value_type&amp; __x_copy = __tmp._M_val();
      const size_type __elems_after = end() - __position;
      pointer __old_finish(this-&gt;_M_impl._M_finish);
      if (__elems_after &gt; __n) &#123;
        // 插入点之后现有的元素个数 &gt; 新增元素个数
        _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
        std::__uninitialized_move_a(this-&gt;_M_impl._M_finish - __n,
                                    this-&gt;_M_impl._M_finish,
                                    this-&gt;_M_impl._M_finish,
                                    _M_get_Tp_allocator());
        this-&gt;_M_impl._M_finish += __n;
        _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
        _GLIBCXX_MOVE_BACKWARD3(__position.base(),
                                __old_finish - __n, __old_finish);
        std::fill(__position.base(), __position.base() + __n, __x_copy);
      &#125; else &#123;
        // 插入点之后现有的元素个数 &lt;= 新增元素个数
          _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
          this-&gt;_M_impl._M_finish =
            std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_finish,
                  __n - __elems_after,
                  __x_copy,
                  _M_get_Tp_allocator());
          _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
          std::__uninitialized_move_a(__position.base(), __old_finish,
                    this-&gt;_M_impl._M_finish,
                    _M_get_Tp_allocator());
          this-&gt;_M_impl._M_finish += __elems_after;
          _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
          std::fill(__position.base(), __old_finish, __x_copy);
            &#125;
      &#125; else &#123;
      // 配置新的 vector 空间
          const size_type __len =
                _M_check_len(__n, &quot;vector::_M_fill_insert&quot;);
          const size_type __elems_before = __position - begin();
          pointer __new_start(this-&gt;_M_allocate(__len));
          pointer __new_finish(__new_start);
          __try &#123;
          // 1、将新增元素以初值为__n, fill 到新空间
          std::__uninitialized_fill_n_a(__new_start + __elems_before,
                __n, __x,
                _M_get_Tp_allocator());

          __new_finish = pointer();
                    // 2、将旧 vector 的插入点之前的元素 copy 到新空间
          __new_finish
            = std::__uninitialized_move_if_noexcept_a
            (this-&gt;_M_impl._M_start, __position.base(),
             __new_start, _M_get_Tp_allocator());

          __new_finish += __n;
                    // 3、将旧 vector 的插入点之后的元素 copy 到新空间
          __new_finish = std::__uninitialized_move_if_noexcept_a(__position.base(), 
                                                 this-&gt;_M_impl._M_finish,
                                                 __new_finish, _M_get_Tp_allocator());
                &#125;
          __catch(...) &#123;
          if (!__new_finish)
            std::_Destroy(__new_start + __elems_before,
              __new_start + __elems_before + __n,
              _M_get_Tp_allocator());
          else
            std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
          _M_deallocate(__new_start, __len);
          __throw_exception_again;
        &#125;

        // 清除释放旧的 vector
          std::_Destroy(this-&gt;_M_impl._M_start, this-&gt;_M_impl._M_finish,
                _M_get_Tp_allocator());
          _GLIBCXX_ASAN_ANNOTATE_REINIT;
          _M_deallocate(this-&gt;_M_impl._M_start,
                this-&gt;_M_impl._M_end_of_storage - this-&gt;_M_impl._M_start);

        // 调整迭代器，指向新的 vector
          this-&gt;_M_impl._M_start = __new_start;
          this-&gt;_M_impl._M_finish = __new_finish;
          this-&gt;_M_impl._M_end_of_storage = __new_start + __len;
        &#125;
    &#125;
&#125;
</code></pre>
</blockquote>
<br/>

<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/vector-insert.png">

<br/>

<br/>

<h3 id="vector-之-erase"><a href="#vector-之-erase" class="headerlink" title="vector 之 erase()"></a>vector 之 erase()</h3><blockquote>
<pre><code class="cpp">// 清除某个位置的元素
template&lt;typename _Tp, typename _Alloc&gt;
typename vector&lt;_Tp, _Alloc&gt;::iterator
  vector&lt;_Tp, _Alloc&gt;::_M_erase(iterator __position) &#123;
      if (__position + 1 != end())
        _GLIBCXX_MOVE3(__position + 1, end(), __position);
      --this-&gt;_M_impl._M_finish;
      _Alloc_traits::destroy(this-&gt;_M_impl, this-&gt;_M_impl._M_finish);
      _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
      return __position;
&#125;

// 清除 [first, last) 中的所有元素
template&lt;typename _Tp, typename _Alloc&gt;
typename vector&lt;_Tp, _Alloc&gt;::iterator
  vector&lt;_Tp, _Alloc&gt;::_M_erase(iterator __first, iterator __last) &#123;
      if (__first != __last) &#123;
        if (__last != end())
          _GLIBCXX_MOVE3(__last, end(), __first);
        _M_erase_at_end(__first.base() + (end() - __last));
      &#125;
      return __first;
&#125;
</code></pre>
</blockquote>
<p>​    <br/></p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/vector-erase.png">

<br/>

<br/>

<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h3 id="list-节点"><a href="#list-节点" class="headerlink" title="list 节点"></a>list 节点</h3><blockquote>
<pre><code class="cpp">// 双向链表
/// Common part of a node in the %list.
struct _List_node_base &#123;
  _List_node_base* _M_next;
  _List_node_base* _M_prev;

  static void
    swap(_List_node_base&amp; __x, _List_node_base&amp; __y) _GLIBCXX_USE_NOEXCEPT;

  void
    _M_transfer(_List_node_base* const __first,
                _List_node_base* const __last) _GLIBCXX_USE_NOEXCEPT;

  void
    _M_reverse() _GLIBCXX_USE_NOEXCEPT;

  void
    _M_hook(_List_node_base* const __position) _GLIBCXX_USE_NOEXCEPT;

  void
    _M_unhook() _GLIBCXX_USE_NOEXCEPT;
&#125;;
</code></pre>
</blockquote>
<br/>

<br/>

<h3 id="list-迭代器"><a href="#list-迭代器" class="headerlink" title="list 迭代器"></a>list 迭代器</h3><blockquote>
<pre><code class="cpp">template&lt;typename _Tp&gt;
struct _List_iterator &#123;
    typedef _List_iterator&lt;_Tp&gt;        _Self;
    typedef _List_node&lt;_Tp&gt;            _Node;

    typedef ptrdiff_t                difference_type;
    typedef std::bidirectional_iterator_tag    iterator_category;
    typedef _Tp                value_type;
    typedef _Tp*                pointer;
    typedef _Tp&amp;                reference;

  _List_iterator() _GLIBCXX_NOEXCEPT
   : _M_node() &#123; &#125;

  explicit
   _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
   : _M_node(__x) &#123; &#125;

    _Self _M_const_cast() const _GLIBCXX_NOEXCEPT &#123; 
       return *this; 
    &#125;

    // Must downcast from _List_node_base to _List_node to get to value.
    reference operator*() const _GLIBCXX_NOEXCEPT &#123; 
       return *static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_valptr(); 
    &#125;

    pointer operator-&gt;() const _GLIBCXX_NOEXCEPT &#123; 
       return static_cast&lt;_Node*&gt;(_M_node)-&gt;_M_valptr(); 
    &#125;

    _Self&amp;  operator++() _GLIBCXX_NOEXCEPT &#123;
       _M_node = _M_node-&gt;_M_next;
       return *this;
    &#125;

    _Self operator++(int) _GLIBCXX_NOEXCEPT &#123;
       _Self __tmp = *this;
       _M_node = _M_node-&gt;_M_next;
       return __tmp;
    &#125;

    _Self&amp; operator--() _GLIBCXX_NOEXCEPT &#123;
       _M_node = _M_node-&gt;_M_prev;
       return *this;
    &#125;

    _Self operator--(int) _GLIBCXX_NOEXCEPT &#123;
       _Self __tmp = *this;
       _M_node = _M_node-&gt;_M_prev;
       return __tmp;
    &#125;

    friend bool
     operator==(const _Self&amp; __x, const _Self&amp; __y) _GLIBCXX_NOEXCEPT &#123; 
       return __x._M_node == __y._M_node; 
    &#125;

    friend bool
     operator!=(const _Self&amp; __x, const _Self&amp; __y) _GLIBCXX_NOEXCEPT &#123; 
       return __x._M_node != __y._M_node; 
    &#125;

    // The only member points to the %list element.
    __detail::_List_node_base* _M_node;
&#125;;
</code></pre>
</blockquote>
<br/>

<h3 id="list-数据结构"><a href="#list-数据结构" class="headerlink" title="list 数据结构"></a>list 数据结构</h3><blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Alloc = std::allocator&lt;_Tp&gt; &gt;
class list : protected _List_base&lt;_Tp, _Alloc&gt; &#123;
    #ifdef _GLIBCXX_CONCEPT_CHECKS
     // concept requirements
     typedef typename _Alloc::value_type        _Alloc_value_type;
    # if __cplusplus &lt; 201103L
     __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
    # endif
       __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
    #endif

    #if __cplusplus &gt;= 201103L
       static_assert(is_same&lt;typename remove_cv&lt;_Tp&gt;::type, _Tp&gt;::value,
                     &quot;std::list must have a non-const, non-volatile value_type&quot;);
    # ifdef __STRICT_ANSI__
     static_assert(is_same&lt;typename _Alloc::value_type, _Tp&gt;::value,
                   &quot;std::list must have the same value_type as its allocator&quot;);
    # endif
    #endif

     typedef _List_base&lt;_Tp, _Alloc&gt;            _Base;
     typedef typename _Base::_Tp_alloc_type        _Tp_alloc_type;
     typedef typename _Base::_Tp_alloc_traits        _Tp_alloc_traits;
     typedef typename _Base::_Node_alloc_type        _Node_alloc_type;
     typedef typename _Base::_Node_alloc_traits    _Node_alloc_traits;

public:
     typedef _Tp                     value_type;
     typedef typename _Tp_alloc_traits::pointer     pointer;
     typedef typename _Tp_alloc_traits::const_pointer     const_pointer;
     typedef typename _Tp_alloc_traits::reference     reference;
     typedef typename _Tp_alloc_traits::const_reference const_reference;
     typedef _List_iterator&lt;_Tp&gt;             iterator;
     typedef _List_const_iterator&lt;_Tp&gt;             const_iterator;
     typedef std::reverse_iterator&lt;const_iterator&gt;     const_reverse_iterator;
     typedef std::reverse_iterator&lt;iterator&gt;         reverse_iterator;
     typedef size_t                     size_type;
     typedef ptrdiff_t                     difference_type;
     typedef _Alloc                     allocator_type;

protected:
     // Note that pointers-to-_Node&#39;s can be ctor-converted to
     // iterator types.
     // 环形双向链表，只需要一个指针便可以表示整个链表
     typedef _List_node&lt;_Tp&gt;                 _Node;
    // ...

    iterator begin() _GLIBCXX_NOEXCEPT &#123; 
       return iterator(this-&gt;_M_impl._M_node._M_next); 
    &#125;

    _GLIBCXX_NODISCARD bool empty() const _GLIBCXX_NOEXCEPT &#123; 
       return this-&gt;_M_impl._M_node._M_next == &amp;this-&gt;_M_impl._M_node; 
    &#125;

    const_reference front() const _GLIBCXX_NOEXCEPT &#123; 
       return *begin(); 
    &#125;

    reference back() _GLIBCXX_NOEXCEPT &#123;
       iterator __tmp = end();
       --__tmp;
       return *__tmp;
    &#125;
    // 配置一个节点并传回
    typename _Node_alloc_traits::pointer _M_get_node() &#123; 
       return _Node_alloc_traits::allocate(_M_impl, 1); 
    &#125;
    // 产生一个节点，带元素值
    template&lt;typename... _Args&gt;
  _Node* _M_create_node(_Args&amp;&amp;... __args) &#123;
    auto __p = this-&gt;_M_get_node();
    auto&amp; __alloc = _M_get_Node_allocator();
    __allocated_ptr&lt;_Node_alloc_type&gt; __guard&#123;__alloc, __p&#125;;
    _Node_alloc_traits::construct(__alloc, __p-&gt;_M_valptr(),
                                  std::forward&lt;_Args&gt;(__args)...);
    __guard = nullptr;
    return __p;
  &#125;
&#125;;
</code></pre>
</blockquote>
<p><br/><br/></p>
<p><strong>list 示意图</strong></p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/list%E7%A4%BA%E6%84%8F%E5%9B%BE.png">

<br/>

<br/>

<h3 id="list-之-unique"><a href="#list-之-unique" class="headerlink" title="list 之 unique()"></a>list 之 unique()</h3><p><strong>list 移除 value 相同元素</strong></p>
<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Alloc&gt;
typename list&lt;_Tp, _Alloc&gt;::__remove_return_type
  list&lt;_Tp, _Alloc&gt;::unique() &#123;
     iterator __first = begin();
     iterator __l

ast = end();
     // 空链表 直接返回
     if (__first == __last) 
       return _GLIBCXX20_ONLY( 0 );
     size_type __removed __attribute__((__unused__)) = 0;
     iterator __next = __first;
     while (++__next != __last) &#123;
       if (*__first == *__next) &#123;
         _M_erase(__next);
         _GLIBCXX20_ONLY( __removed++ );
       &#125;
       else
         __first = __next;
       __next = __first;
     &#125;
     return _GLIBCXX20_ONLY( __removed );
&#125;
</code></pre>
</blockquote>
<br/>

<br/>

<h3 id="list-之-erase"><a href="#list-之-erase" class="headerlink" title="list 之 erase()"></a>list 之 erase()</h3><blockquote>
<pre><code class="cpp">iterator erase(iterator __position) &#123;
       _List_node_base* __next_node = __position._M_node-&gt;_M_next;
       _List_node_base* __prev_node = __position._M_node-&gt;_M_prev;
       _Node* __n = (_Node*) __position._M_node;
       __prev_node-&gt;_M_next = __next_node;
       __next_node-&gt;_M_prev = __prev_node;
       _Destroy(&amp;__n-&gt;_M_data);
       _M_put_node(__n);
       return iterator((_Node*) __next_node);
&#125;
</code></pre>
</blockquote>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/list-erase.png">

<br/>

<br/>

<h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h3><p><strong>将 [first, last) 内的所有元素移动到 position 之前</strong></p>
<blockquote>
<pre><code class="cpp">// SGI STL 版本
void transfer(iterator __position, iterator __first, iterator __last) &#123;
    if (__position != __last) &#123;
      // Remove [first, last) from its old position.
      __last._M_node-&gt;_M_prev-&gt;_M_next     = __position._M_node;  // 1
      __first._M_node-&gt;_M_prev-&gt;_M_next    = __last._M_node;          // 2
      __position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node;     // 3

      // Splice [first, last) into its new position.
      _List_node_base* __tmp      = __position._M_node-&gt;_M_prev;  // 4
      __position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;      // 5
      __last._M_node-&gt;_M_prev     = __first._M_node-&gt;_M_prev;     // 6
      __first._M_node-&gt;_M_prev    = __tmp;                                              // 7
    &#125;
&#125;
</code></pre>
</blockquote>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/list-transfer.png">

<br/>

<h3 id="list-之-splice"><a href="#list-之-splice" class="headerlink" title="list 之 splice()"></a>list 之 splice()</h3><p><strong>transfer() 是非公开接口，STL 为 list 提供了splice()。</strong></p>
<blockquote>
<pre><code class="cpp">void splice(iterator __position, list&amp; __x) &#123;
     if (!__x.empty()) 
       this-&gt;transfer(__position, __x.begin(), __x.end());
&#125;

void splice(iterator __position, list&amp;, iterator __i) &#123;
     iterator __j = __i;
     ++__j;
     if (__position == __i || __position == __j) return;
     this-&gt;transfer(__position, __i, __j);
&#125;

void splice(iterator __position, list&amp;, iterator __first, iterator __last) &#123;
     if (__first != __last) 
       this-&gt;transfer(__position, __first, __last);
&#125;
</code></pre>
</blockquote>
<br/>

<blockquote>
<pre><code class="cpp">#include &lt;algorithm&gt;
#include &lt;list&gt;

int main() &#123;
      std::list&lt;int&gt; list1 &#123; 1, 2, 3, 4, 100 &#125;;
      std::list&lt;int&gt; list2 &#123; 5, 6, 7, 8, 9 &#125;;

      auto iter = std::find(list1.begin(), list1.end(), 100);
      list1.splice(iter, list2);  // 1, 2, 3, 4, [5, 6, 7, 8, 9] 100
      list1.reverse();            //100, 9, 8, 7, 6, 5, 4, 3, 2, 1
      list1.sort();               // 1, 2, 3, 4, 5, 6, 7, 8, 9, 100

      return 0;
&#125;
</code></pre>
</blockquote>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/list-splice.png">

<p><br/><br/></p>
<h3 id="list-之-merge"><a href="#list-之-merge" class="headerlink" title="list 之 merge()"></a>list 之 merge()</h3><blockquote>
<pre><code class="cpp">template &lt;class _Tp, class _Alloc&gt;
void list&lt;_Tp, _Alloc&gt;::merge(list&lt;_Tp, _Alloc&gt;&amp; __x) &#123;
      iterator __first1 = begin();
      iterator __last1 = end();
      iterator __first2 = __x.begin();
      iterator __last2 = __x.end();
      // 两个 list 都已经递增排序
      while (__first1 != __last1 &amp;&amp; __first2 != __last2)
        if (*__first2 &lt; *__first1) &#123;
          iterator __next = __first2;
          transfer(__first1, __first2, ++__next);
          __first2 = __next;
        &#125;
        else
         ++__first1;
      if (__first2 != __last2) transfer(__last1, __first2, __last2);
&#125;
</code></pre>
</blockquote>
<br/>

<h3 id="list-之-reverse"><a href="#list-之-reverse" class="headerlink" title="list 之 reverse()"></a>list 之 reverse()</h3><blockquote>
<pre><code class="cpp">inline void __List_base_reverse(_List_node_base* __p) &#123;
   _List_node_base* __tmp = __p;
      do &#123;
        __STD::swap(__tmp-&gt;_M_next, __tmp-&gt;_M_prev);
        __tmp = __tmp-&gt;_M_prev;     // Old next node is now prev.
      &#125; while (__tmp != __p);
   &#125;

template &lt;class _Tp, class _Alloc&gt;
inline void list&lt;_Tp, _Alloc&gt;::reverse() &#123;
      __List_base_reverse(this-&gt;_M_node);
&#125; 
</code></pre>
</blockquote>
<br/>

<h3 id="list-之-sort"><a href="#list-之-sort" class="headerlink" title="list 之 sort()"></a>list 之 sort()</h3><blockquote>
<pre><code class="cpp">template &lt;class _Tp, class _Alloc&gt;
void list&lt;_Tp, _Alloc&gt;::sort() &#123;
  // Do nothing if the list has length 0 or 1.
  if (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) &#123;
     list&lt;_Tp, _Alloc&gt; __carry;
     list&lt;_Tp, _Alloc&gt; __counter[64];
     int __fill = 0;
     while (!empty()) &#123;
       __carry.splice(__carry.begin(), *this, begin());
       int __i = 0;
       while(__i &lt; __fill &amp;&amp; !__counter[__i].empty()) &#123;
         __counter[__i].merge(__carry);
         __carry.swap(__counter[__i++]);
       &#125;
       __carry.swap(__counter[__i]);         
       if (__i == __fill) ++__fill;
     &#125; 

     for (int __i = 1; __i &lt; __fill; ++__i)
       __counter[__i].merge(__counter[__i-1]);
     swap(__counter[__fill-1]);
  &#125;
&#125;
</code></pre>
</blockquote>
<br/>

<br/>

<p><strong>list 使用注意事项</strong></p>
<p><code>由于 list 的迭代器类型是 Bidirectional Iterators, 而 std::sort() 要求的是 RandomAccessIterator, 必须使用自身的 sort() 函数排序，否则会报错：</code></p>
<blockquote>
<pre><code class="shell">/usr/include/c++/9/bits/stl_algo.h: In instantiation of ‘void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = std::_List_iterator&lt;int&gt;; _Compare = __gnu_cxx::__ops::_Iter_less_iter]’:
/usr/include/c++/9/bits/stl_algo.h:4867:18:   required from ‘void std::sort(_RAIter, _RAIter) [with _RAIter = std::_List_iterator&lt;int&gt;]’
required from here
/usr/include/c++/9/bits/stl_algo.h:1968:22: error: no match for ‘operator-’ (operand types are ‘std::_List_iterator&lt;int&gt;’ and ‘std::_List_iterator&lt;int&gt;’)
 1968 |     std::__lg(__last - __first) * 2,
</code></pre>
</blockquote>
<p><br/><br/></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/deque.png">

<table>
<thead>
<tr>
<th align="center">deque</th>
<th align="center">vector</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>（支持头尾两端插入删除）双向</strong>、开口</td>
<td align="center"><strong>（头部操作效率极差）单向</strong>、开口</td>
</tr>
<tr>
<td align="center">允许<strong>常数时间</strong>内对起头端进行元素的插入/移出</td>
<td align="center">尾端成长</td>
</tr>
<tr>
<td align="center"><strong>没有capacity()</strong> 概念</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">动态地以分段连续空间组合而成、随时增加一段新空间并链接起来</td>
<td align="center">空间不足时，存在 <strong>reallocate()</strong> 新空间，<strong>destroy()</strong> 旧空间</td>
</tr>
<tr>
<td align="center"><strong>没必要提供 reserve()</strong> 功能</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">Ramdon Access Iterator 复杂度比 vector 高</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">对 deque 排序，可以先复制到 vector 排序后再 copy 回来</td>
<td align="center"></td>
</tr>
</tbody></table>
<br/>

<blockquote>
<pre><code class="cpp">// map 是一个 T**
template&lt;typename _Tp, typename _Alloc&gt;
class _Deque_base &#123;
protected:
  typedef typename iterator::_Map_pointer _Map_pointer;
  struct _Deque_impl : public _Tp_alloc_type &#123;
   _Map_pointer _M_map;        // 指向 map, 存储 T** 类型的连续空间
   size_t _M_map_size;         // buffer 块数
   iterator _M_start;            // 指向第一个 buffer
   iterator _M_finish;            // 指向最后一个 buffer
   _Deque_impl() 
     : _Tp_alloc_type(), 
     _M_map(), 
     _M_map_size(0),
       _M_start(), 
     _M_finish() &#123; &#125;
   // ...
  &#125;;
  _Deque_impl _M_impl;
// ...
&#125;;
</code></pre>
</blockquote>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/deque-map-node-buffer.png">

<br/>

<h3 id="deque-迭代器"><a href="#deque-迭代器" class="headerlink" title="deque 迭代器"></a>deque 迭代器</h3><ul>
<li>能够指出分段连续空间（buffer）的位置</li>
<li>能够判断当前所处的 buffer 的边缘</li>
<li>能够控制 map 跳跃到上一个/下一个buffer</li>
</ul>
<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Ref, typename _Ptr&gt;
struct _Deque_iterator &#123;  // 未继承 std::iterator
  #if __cplusplus &lt; 201103L
  typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;         iterator;
  typedef _Deque_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;
  typedef _Tp*                     _Elt_pointer;
  typedef _Tp**                    _Map_pointer;
  #else
private:
  template&lt;typename _Up&gt;
  using __ptr_to = typename pointer_traits&lt;_Ptr&gt;::template rebind&lt;_Up&gt;;
  template&lt;typename _CvTp&gt;
  using __iter = _Deque_iterator&lt;_Tp, _CvTp&amp;, __ptr_to&lt;_CvTp&gt;&gt;;
public:
  typedef __iter&lt;_Tp&gt;        iterator;
  typedef __iter&lt;const _Tp&gt;        const_iterator;
  typedef __ptr_to&lt;_Tp&gt;        _Elt_pointer;
  typedef __ptr_to&lt;_Elt_pointer&gt;    _Map_pointer;
  #endif

  /**
   *  @brief This function controls the size of memory nodes.
   *  @param  __size  The size of an element.
   *  @return   The number (not byte size) of elements per node.
   */
  // 决定 buffer 大小的函数
  // buffer size 默认值 _GLIBCXX_DEQUE_BUF_SIZE 512
  // 如果元素大小 __size &lt; 512 传回 512/__size; 否则传回 1
  _GLIBCXX_CONSTEXPR inline size_t __deque_buf_size(size_t __size) &#123; 
    return (__size &lt; _GLIBCXX_DEQUE_BUF_SIZE
        ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); 
  &#125;
  static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT &#123; 
    return __deque_buf_size(sizeof(_Tp)); 
  &#125;

  // 未继承 std::iterator 所以必须自行撰写5个必要的迭代器相应类型
  typedef std::random_access_iterator_tag    iterator_category;
  typedef _Tp                value_type;
  typedef _Ptr                pointer;
  typedef _Ref                reference;
  typedef size_t                size_type;
  typedef ptrdiff_t                difference_type;
  typedef _Deque_iterator            _Self;

  _Elt_pointer _M_cur;    // 指向某个 buffer 的当前元素
  _Elt_pointer _M_first;  // 指向某个 buffer 的头
  _Elt_pointer _M_last;   // 指向某个 buffer 的尾（含备用空间）
  _Map_pointer _M_node;   // 指向管控中心
  // ...
&#125;;
</code></pre>
</blockquote>
<br/>

<p><strong>deque 迭代器关键行为</strong></p>
<blockquote>
<pre><code class="cpp">// 一旦遇到 buffer 边缘，就要调用 _M_set_node
// 跳一个 buffer
void _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT &#123;
  _M_node = __new_node;
  _M_first = *__new_node;
  _M_last = _M_first + difference_type(_S_buffer_size());
&#125;

_Self&amp; operator++() _GLIBCXX_NOEXCEPT &#123;
  ++_M_cur;                                      // 切到下一个元素
  if (_M_cur == _M_last) &#123;        // 如果到达 buffer 尾端
    _M_set_node(_M_node + 1); // 切到下一个节点（即下一块 buffer）
    _M_cur = _M_first;                // 的第一个元素
  &#125;
  return *this;
&#125;


_Self&amp; operator--() _GLIBCXX_NOEXCEPT &#123;
  if (_M_cur == _M_first) &#123;        // 如果到达 buffer 头端
    _M_set_node(_M_node - 1); // 切到上一个节点（即上一块 buffer）
    _M_cur = _M_last;                    // 的最后一个元素
  &#125;
  --_M_cur;
  return *this;
&#125;

// 随机存取 迭代器可以直接跳跃 n 个距离
_Self&amp; operator+=(difference_type __n) _GLIBCXX_NOEXCEPT &#123;
  const difference_type __offset = __n + (_M_cur - _M_first);
  // 目标位置在 同一个 buffer 内
  if (__offset &gt;= 0 &amp;&amp; __offset &lt; difference_type(_S_buffer_size()))
    _M_cur += __n;
  else &#123;
    // 目标位置不在 同一个 buffer 内
    const difference_type __node_offset =
      __offset &gt; 0 ? __offset / difference_type(_S_buffer_size())
      : -difference_type((-__offset - 1)
                         / _S_buffer_size()) - 1;
    // 切换到正确的 buffer
    _M_set_node(_M_node + __node_offset);
    // 切换正确的元素
    _M_cur = _M_first + (__offset - __node_offset
                         * difference_type(_S_buffer_size()));
  &#125;
  return *this;
&#125;

// 利用 operator+=
_Self&amp; operator-=(difference_type __n) _GLIBCXX_NOEXCEPT &#123; 
  return *this += -__n; 
&#125;

iterator begin() _GLIBCXX_NOEXCEPT &#123; 
  return this-&gt;_M_impl._M_start; 
&#125;

iterator end() _GLIBCXX_NOEXCEPT &#123; 
  return this-&gt;_M_impl._M_finish; 
&#125;
</code></pre>
</blockquote>
<br/>

<img title="deque 中控器、缓存区、迭代器的关系" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/deque-map-buffer-iterator.png">

<br/>

<h3 id="deque-创建"><a href="#deque-创建" class="headerlink" title="deque 创建"></a>deque 创建</h3><blockquote>
<pre><code class="cpp">/**
*  @brief  Creates a %deque with copies of an exemplar element.
*  @param  __n  The number of elements to initially create.
*  @param  __value  An element to copy.
*  @param  __a  An allocator.
*
*  This constructor fills the %deque with @a __n copies of @a __value.
*/
deque(size_type __n, const value_type&amp; __value,
      const allocator_type&amp; __a = allocator_type())
: _Base(__a, _S_check_init_len(__n, __a)) &#123; 
    _M_fill_initialize(__value); 
&#125;

_Deque_base(const allocator_type&amp; __a, size_t __num_elements)
  : _M_impl(__a) &#123; 
    _M_initialize_map(__num_elements); 
&#125;
</code></pre>
</blockquote>
<br/>

<blockquote>
<pre><code class="cpp">template &lt;typename _Tp, typename _Alloc&gt;
void deque&lt;_Tp, _Alloc&gt;:: _M_fill_initialize(const value_type&amp; __value) &#123;
  _Map_pointer __cur;
  __try &#123;
    // 为每个节点的 buffer 设定初值
    for (__cur = this-&gt;_M_impl._M_start._M_node;
         __cur &lt; this-&gt;_M_impl._M_finish._M_node;
         ++__cur)
      std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
                                  __value, _M_get_Tp_allocator());
    // 最后节点的设定稍有不同，考虑尾端可能有备用空间，不必设初值
    std::__uninitialized_fill_a(this-&gt;_M_impl._M_finish._M_first,
                                this-&gt;_M_impl._M_finish._M_cur,
                                __value, _M_get_Tp_allocator());
  &#125;
  __catch(...) &#123;
        // ...
  &#125;
&#125;
</code></pre>
</blockquote>
<br/>

<p><strong>_M_create_nodes()</strong></p>
<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Alloc&gt;
void
_Deque_base&lt;_Tp, _Alloc&gt;::
_M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish) &#123;
  _Map_pointer __cur;
  __try &#123;
    for (__cur = __nstart; __cur &lt; __nfinish; ++__cur)
      *__cur = this-&gt;_M_allocate_node();
  &#125;
  __catch(...) &#123;
        // ...
  &#125;
&#125;

_Ptr _M_allocate_node() &#123;
  typedef __gnu_cxx::__alloc_traits&lt;_Tp_alloc_type&gt; _Traits;
  return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
&#125;

// 决定 buffer 大小的函数
// buffer size 默认值 _GLIBCXX_DEQUE_BUF_SIZE 512
// 如果元素大小 __size &lt; 512 传回 512/__size; 否则传回 1
_GLIBCXX_CONSTEXPR inline size_t __deque_buf_size(size_t __size) &#123; 
  return (__size &lt; _GLIBCXX_DEQUE_BUF_SIZE
          ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); 
&#125;
</code></pre>
</blockquote>
<br/>

<p><strong>_M_initialize_map()</strong></p>
<blockquote>
<pre><code class="cpp">/**
*  @brief Layout storage.
*  @param  __num_elements  The count of T&#39;s for which to allocate space
*                          at first.
*  @return   Nothing.
*  The initial underlying memory layout is a bit complicated...
*/
template&lt;typename _Tp, typename _Alloc&gt;
void _Deque_base&lt;_Tp, _Alloc&gt;:: _M_initialize_map(size_t __num_elements) &#123;
  // 需要 map_pointer 节点数 = （元素个数 / 每个缓冲区可容纳的元素个数）+ 1
  // 因为 deque::end() 返回的是 finish 迭代器，所以分配多一个节点
  const size_t __num_nodes = (__num_elements / __deque_buf_size(sizeof(_Tp))
                              + 1);
  // 一个中控器需要管理几个节点，
  // 至少： _S_initial_map_size = 8 个
  // 最多： 所需 map_pointer 节点数 + 2（前后各自预备一个，方便扩充）
  this-&gt;_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
                                       size_t(__num_nodes + 2));
  this-&gt;_M_impl._M_map = _M_allocate_map(this-&gt;_M_impl._M_map_size);
    // 以上就配置出了 一个 具有 _M_map_size 个节点的中控器


  // 令 nstart 和 nfinish 指向 map 所拥有全部节点的最中央区段
  // 保持最中央可以保证 deque 两端生长的能力一样大
  _Map_pointer __nstart = (this-&gt;_M_impl._M_map
                           + (this-&gt;_M_impl._M_map_size - __num_nodes) / 2);
  _Map_pointer __nfinish = __nstart + __num_nodes;

  __try &#123;
    _M_create_nodes(__nstart, __nfinish); 
  &#125;
  __catch(...) &#123;
        // ...
  &#125;
  // 为 deque 内的两个迭代器 start 和 finish 设定正确的内容
  this-&gt;_M_impl._M_start._M_set_node(__nstart);
  this-&gt;_M_impl._M_finish._M_set_node(__nfinish - 1);
  this-&gt;_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
  // 因为刚好整除会多配置一个节点，
  // 此时，cur 指向这个多配置的一个节点
  this-&gt;_M_impl._M_finish._M_cur = (this-&gt;_M_impl._M_finish._M_first
                                    + __num_elements
                                    % __deque_buf_size(sizeof(_Tp)));
&#125;
</code></pre>
</blockquote>
<br/>

<p><strong>std::deque<int> ideq(512, 1)</strong></p>
<p><code>int 类型的 deque 决定了 __deque_buf_size（一块 buffer 的大小）为 512 / sizeof(int) = 128</code>。</p>
<p><code>512 个元素决定了中控器需要 __num_nodes（buffer 块数）为 (512 / 128) + 1) = 5</code>。</p>
<p><code>中控器大小 _M_map_size 为 std::max(8, (buffer 个数 + 2)) = 8</code>。</p>
<br/>

<img title="deque 构造示例" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/deque-construct.png">

<br/>

<h3 id="deque-之-push-back"><a href="#deque-之-push-back" class="headerlink" title="deque 之 push_back()"></a>deque 之 push_back()</h3><blockquote>
<pre><code class="cpp">void push_back(const value_type&amp; __x) &#123;
    // 最后 buffer 还有2个及以上的元素备用空间
  if (this-&gt;_M_impl._M_finish._M_cur != this-&gt;_M_impl._M_finish._M_last - 1) &#123;
    _Alloc_traits::construct(this-&gt;_M_impl,
                             this-&gt;_M_impl._M_finish._M_cur, __x);
    ++this-&gt;_M_impl._M_finish._M_cur;
  &#125;
  else
    _M_push_back_aux(__x); // 最后 buffer 只剩1个元素备用空间
&#125;

template&lt;typename _Tp, typename _Alloc&gt;
template&lt;typename... _Args&gt;
void deque&lt;_Tp, _Alloc&gt;::
_M_push_back_aux(_Args&amp;&amp;... __args) &#123;
  if (size() == max_size())
    __throw_length_error(
    __N(&quot;cannot create std::deque larger than max_size()&quot;));

  _M_reserve_map_at_back();            // 如果中控器后端节点不足，必须重换一个 map
  // 配置一个新的节点（新 buffer 块）
  *(this-&gt;_M_impl._M_finish._M_node + 1) = this-&gt;_M_allocate_node();
  __try &#123;
    // 针对标的元素设值
    _Alloc_traits::construct(this-&gt;_M_impl,
                             this-&gt;_M_impl._M_finish._M_cur,
                             std::forward&lt;_Args&gt;(__args)...);
    // 改变 finish，指向新节点（新 buffer 块）
    this-&gt;_M_impl._M_finish._M_set_node(this-&gt;_M_impl._M_finish._M_node + 1);
    // 设定 finish 状态
    this-&gt;_M_impl._M_finish._M_cur = this-&gt;_M_impl._M_finish._M_first;
  &#125;
  __catch(...) &#123;
        // ...
  &#125;
&#125;

// 中控器后端节点不足，重新分配中控器空间
void _M_reserve_map_at_back(size_type __nodes_to_add = 1) &#123;
  if (__nodes_to_add + 1 &gt; this-&gt;_M_impl._M_map_size
      - (this-&gt;_M_impl._M_finish._M_node - this-&gt;_M_impl._M_map))
    _M_reallocate_map(__nodes_to_add, false);
&#125;
</code></pre>
</blockquote>
<br/>

<img title="push_back" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/deque-push-back.png">

<br/>

<h3 id="deque-之-pop-back"><a href="#deque-之-pop-back" class="headerlink" title="deque 之 pop_back()"></a>deque 之 pop_back()</h3><blockquote>
<pre><code class="cpp">void pop_back() _GLIBCXX_NOEXCEPT &#123;
  __glibcxx_requires_nonempty();
  // 最后一个 buffer 有一个或者更多的元素
  if (this-&gt;_M_impl._M_finish._M_cur
      != this-&gt;_M_impl._M_finish._M_first) &#123;
    --this-&gt;_M_impl._M_finish._M_cur;                // 调整 finish.cur 指针
    // 析构最后一个元素
    _Alloc_traits::destroy(this-&gt;_M_impl,
                           this-&gt;_M_impl._M_finish._M_cur);
  &#125;
  // 最后一个 buffer 没有任何元素
  else
    _M_pop_back_aux(); // 释放 buffer 操作
&#125;

// 当 finish 指向的 buffer 没有任何一个元素时调用
template &lt;typename _Tp, typename _Alloc&gt;
void deque&lt;_Tp, _Alloc&gt;::
_M_pop_back_aux() &#123;
  // 释放最后一个 buffer
  _M_deallocate_node(this-&gt;_M_impl._M_finish._M_first);
  // 调整 finish 指向上一个 buffer
  this-&gt;_M_impl._M_finish._M_set_node(this-&gt;_M_impl._M_finish._M_node - 1);
  // 找到 buffer（原来倒数第二个 buffer 块） 的最后一个元素
  this-&gt;_M_impl._M_finish._M_cur = this-&gt;_M_impl._M_finish._M_last - 1;
  // 析构元素
  _Alloc_traits::destroy(_M_get_Tp_allocator(),
                         this-&gt;_M_impl._M_finish._M_cur);
&#125;
</code></pre>
</blockquote>
<br/>

<h3 id="deque-之-push-front"><a href="#deque-之-push-front" class="headerlink" title="deque 之 push_front()"></a>deque 之 push_front()</h3><blockquote>
<pre><code class="cpp">void push_front(const value_type&amp; __x) &#123;
// 第一个 buffer 有元素备用空间
if (this-&gt;_M_impl._M_start._M_cur != this-&gt;_M_impl._M_start._M_first) &#123;
 _Alloc_traits::construct(this-&gt;_M_impl,
                          this-&gt;_M_impl._M_start._M_cur - 1,
                          __x);
 --this-&gt;_M_impl._M_start._M_cur;    // 调整 第一块 buffer 使用状态
&#125;
else
 _M_push_front_aux(__x);        // 第一个 buffer 已无元素备用空间
&#125;

template&lt;typename... _Args&gt;
void deque&lt;_Tp, _Alloc&gt;::_M_push_front_aux(_Args&amp;&amp;... __args) &#123;
if (size() == max_size())
 __throw_length_error(
 __N(&quot;cannot create std::deque larger than max_size()&quot;));

_M_reserve_map_at_front();  // 如果中控器前端节点不足，重新分配中控器空间
// 配置一个新的节点（新 buffer 块）
*(this-&gt;_M_impl._M_start._M_node - 1) = this-&gt;_M_allocate_node();
__try &#123;
 // 改变 start 指向新的 buffer 块
 this-&gt;_M_impl._M_start._M_set_node(this-&gt;_M_impl._M_start._M_node
                                       - 1);
    // start 的 cur 指向 新插入元素
    this-&gt;_M_impl._M_start._M_cur = this-&gt;_M_impl._M_start._M_last - 1;
        // 设定新插入元素的值
    _Alloc_traits::construct(this-&gt;_M_impl,
                             this-&gt;_M_impl._M_start._M_cur,
                             std::forward&lt;_Args&gt;(__args)...);
  &#125;
  __catch(...) &#123;
    // ...
  &#125;
&#125;

// 中控器前端节点不足，重新分配中控器空间
void _M_reserve_map_at_front(size_type __nodes_to_add = 1) &#123;
  if (__nodes_to_add &gt; size_type(this-&gt;_M_impl._M_start._M_node
                                 - this-&gt;_M_impl._M_map))
    _M_reallocate_map(__nodes_to_add, true);
&#125;
</code></pre>
</blockquote>
<br/>

<img title="push_front" src ="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/deque-push-front.png">

<br/>

<h3 id="deque-之-pop-front"><a href="#deque-之-pop-front" class="headerlink" title="deque 之 pop_front()"></a>deque 之 pop_front()</h3><blockquote>
<pre><code class="cpp">void pop_front() _GLIBCXX_NOEXCEPT &#123;
  __glibcxx_requires_nonempty();
  // 第一个 buffer 有超过1个元素
  if (this-&gt;_M_impl._M_start._M_cur
      != this-&gt;_M_impl._M_start._M_last - 1) &#123;
    _Alloc_traits::destroy(this-&gt;_M_impl,
                           this-&gt;_M_impl._M_start._M_cur);
    ++this-&gt;_M_impl._M_start._M_cur;
  &#125;
  // 第一个 buffer 仅有一个元素，涉及 buffer 释放 
  else
    _M_pop_front_aux();
&#125;

// 当第一个 buffer 仅有一个元素时，会调用
template &lt;typename _Tp, typename _Alloc&gt;
void deque&lt;_Tp, _Alloc&gt;::
_M_pop_front_aux() &#123;
  // 将第一个 buffer 仅剩的唯一一个元素析构
  _Alloc_traits::destroy(_M_get_Tp_allocator(),
                         this-&gt;_M_impl._M_start._M_cur);
  // 释放第一个 buffer
  _M_deallocate_node(this-&gt;_M_impl._M_start._M_first);
  // 调整 迭代器 start 的状态指向原来第2个 buffer 块
  this-&gt;_M_impl._M_start._M_set_node(this-&gt;_M_impl._M_start._M_node + 1);
  //
  this-&gt;_M_impl._M_start._M_cur = this-&gt;_M_impl._M_start._M_first;
&#125;
</code></pre>
</blockquote>
<br/>

<h3 id="重新配置中控器"><a href="#重新配置中控器" class="headerlink" title="重新配置中控器"></a>重新配置中控器</h3><blockquote>
<pre><code class="cpp">template &lt;typename _Tp, typename _Alloc&gt;
void
deque&lt;_Tp, _Alloc&gt;::
_M_reallocate_map(size_type __nodes_to_add, bool __add_at_front) &#123;
  const size_type __old_num_nodes
    = this-&gt;_M_impl._M_finish._M_node - this-&gt;_M_impl._M_start._M_node + 1;
  const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

  _Map_pointer __new_nstart;
  if (this-&gt;_M_impl._M_map_size &gt; 2 * __new_num_nodes) &#123;
    __new_nstart = this-&gt;_M_impl._M_map + (this-&gt;_M_impl._M_map_size
                                           - __new_num_nodes) / 2
      + (__add_at_front ? __nodes_to_add : 0);
    if (__new_nstart &lt; this-&gt;_M_impl._M_start._M_node)
      std::copy(this-&gt;_M_impl._M_start._M_node,
                this-&gt;_M_impl._M_finish._M_node + 1,
                __new_nstart);
    else
      std::copy_backward(this-&gt;_M_impl._M_start._M_node,
                         this-&gt;_M_impl._M_finish._M_node + 1,
                         __new_nstart + __old_num_nodes);
  &#125; else &#123;
    size_type __new_map_size = this-&gt;_M_impl._M_map_size
      + std::max(this-&gt;_M_impl._M_map_size,
                 __nodes_to_add) + 2;
        // 配置一块新的空间， 准备给新的 map （中控器）使用
    _Map_pointer __new_map = this-&gt;_M_allocate_map(__new_map_size);
    __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
      + (__add_at_front ? __nodes_to_add : 0);
    // 拷贝原 中控器 内容
    std::copy(this-&gt;_M_impl._M_start._M_node,
              this-&gt;_M_impl._M_finish._M_node + 1,
              __new_nstart);
    // 释放原 map（中控器）
    _M_deallocate_map(this-&gt;_M_impl._M_map, this-&gt;_M_impl._M_map_size);
        // 新 map （中控器）的起始地址和大小
    this-&gt;_M_impl._M_map = __new_map;
    this-&gt;_M_impl._M_map_size = __new_map_size;
  &#125;
    // 重新设置 start、finish 迭代器
  this-&gt;_M_impl._M_start._M_set_node(__new_nstart);
  this-&gt;_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
&#125;
</code></pre>
</blockquote>
<br/>

<h3 id="deque-之-insert"><a href="#deque-之-insert" class="headerlink" title="deque 之 insert()"></a>deque 之 insert()</h3><blockquote>
<pre><code class="cpp">template &lt;typename _Tp, typename _Alloc&gt;
typename deque&lt;_Tp, _Alloc&gt;::iterator
  deque&lt;_Tp, _Alloc&gt;::
insert(const_iterator __position, const value_type&amp; __x) &#123;
  // 如果插入点是 deque 的最前端
  if (__position._M_cur == this-&gt;_M_impl._M_start._M_cur) &#123;
    // 交给 push_front() 做
    push_front(__x);
    return this-&gt;_M_impl._M_start;
  &#125;
  // 如果插入点是 deque 的最尾端
  else if (__position._M_cur == this-&gt;_M_impl._M_finish._M_cur) &#123;
    // 交给 push_back() 做
    push_back(__x);
    iterator __tmp = this-&gt;_M_impl._M_finish;
    --__tmp;
    return __tmp;
  &#125;
  else
    return _M_insert_aux(__position._M_const_cast(), __x);
&#125;


template&lt;typename _Tp, typename _Alloc&gt;
template&lt;typename... _Args&gt;
typename deque&lt;_Tp, _Alloc&gt;::iterator
  deque&lt;_Tp, _Alloc&gt;::_M_insert_aux(iterator __pos, _Args&amp;&amp;... __args) &#123;
    value_type __x_copy(std::forward&lt;_Args&gt;(__args)...);
        // 插入点之前的元素个数
    difference_type __index = __pos - this-&gt;_M_impl._M_start;
    //如果插入点之前的元素较少
    if (static_cast&lt;size_type&gt;(__index) &lt; size() / 2) &#123;
      //  push_front 进行一个前端元素的添加
      push_front(_GLIBCXX_MOVE(front()));
      iterator __front1 = this-&gt;_M_impl._M_start;
      ++__front1;
      iterator __front2 = __front1;
      ++__front2;
      __pos = this-&gt;_M_impl._M_start + __index;
      iterator __pos1 = __pos;
      ++__pos1;
      // 将插入点之前的元素前移，腾出1个元素空间
      _GLIBCXX_MOVE3(__front2, __pos1, __front1);
    &#125; else &#123;
      //  push_back 进行一个后端元素的添加
      push_back(_GLIBCXX_MOVE(back()));
      iterator __back1 = this-&gt;_M_impl._M_finish;
      --__back1;
      iterator __back2 = __back1;
      --__back2;
      __pos = this-&gt;_M_impl._M_start + __index;
      // 将插入点后面的元素再往后移，腾出1个元素空间
      _GLIBCXX_MOVE_BACKWARD3(__pos, __back2, __back1);
    &#125;
    // 插入点设置新值
    *__pos = _GLIBCXX_MOVE(__x_copy);
    return __pos;
&#125;
</code></pre>
</blockquote>
<br/>

<h3 id="deque-之-erase"><a href="#deque-之-erase" class="headerlink" title="deque 之 erase()"></a>deque 之 erase()</h3><blockquote>
<pre><code class="cpp">// 按个擦除
template &lt;typename _Tp, typename _Alloc&gt;
typename deque&lt;_Tp, _Alloc&gt;::iterator
  deque&lt;_Tp, _Alloc&gt;::
_M_erase(iterator __position) &#123;
  iterator __next = __position;
  ++__next;
  // 擦除点之前的元素个数
  const difference_type __index = __position - begin();
  // 如果擦除点之前的元素个数较少
  if (static_cast&lt;size_type&gt;(__index) &lt; (size() &gt;&gt; 1)) &#123;
    // 前移擦除点之前的元素，只有调用 pop_front()
    if (__position != begin())
      _GLIBCXX_MOVE_BACKWARD3(begin(), __position, __next);
    pop_front();
  &#125; else &#123;
    // 擦除点之后的元素个数较少
    // 前移擦除点之后的元素，只有调用 pop_back()
    if (__next != end())
      _GLIBCXX_MOVE3(__next, end(), __position);
    pop_back();
  &#125;
  return begin() + __index;
&#125;

// 按区间擦除
template &lt;typename _Tp, typename _Alloc&gt;
typename deque&lt;_Tp, _Alloc&gt;::iterator
  deque&lt;_Tp, _Alloc&gt;::
_M_erase(iterator __first, iterator __last) &#123;
  if (__first == __last)
    return __first;
  // 擦除区间是真个 deque
  else if (__first == begin() &amp;&amp; __last == end()) &#123;
    clear();
    return end();
  &#125; else &#123;
    // 计算擦除区间长度
    const difference_type __n = __last - __first;
    const difference_type __elems_before = __first - begin();
    // 如果要擦除区间前面的元素较少
    if (static_cast&lt;size_type&gt;(__elems_before) &lt;= (size() - __n) / 2) &#123;
      // 后移前方的元素
      if (__first != begin())
        _GLIBCXX_MOVE_BACKWARD3(begin(), __first, __last);
      // 析构 冗余的元素
      _M_erase_at_begin(begin() + __n);
    &#125; else &#123;
      // 前移后方的元素
      if (__last != end())
        _GLIBCXX_MOVE3(__last, end(), __first);
      // 析构 冗余的元素
      _M_erase_at_end(end() - __n);
    &#125;
    return begin() + __elems_before;
  &#125;
&#125;

// 将冗余的 buffer 释放
void _M_erase_at_begin(iterator __pos) &#123;
  _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
  _M_destroy_nodes(this-&gt;_M_impl._M_start._M_node, __pos._M_node);
  this-&gt;_M_impl._M_start = __pos; // 设置 deque 新起点
&#125;

// 将冗余的 buffer 释放
void _M_erase_at_end(iterator __pos) &#123;
  _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
  _M_destroy_nodes(__pos._M_node + 1,
                   this-&gt;_M_impl._M_finish._M_node + 1);
  this-&gt;_M_impl._M_finish = __pos; // 设置 deque 新尾点
&#125;
</code></pre>
</blockquote>
<br/>

<h3 id="deque-之-clear"><a href="#deque-之-clear" class="headerlink" title="deque 之 clear()"></a>deque 之 clear()</h3><blockquote>
<pre><code class="cpp">void clear() _GLIBCXX_NOEXCEPT &#123; 
  _M_erase_at_end(begin()); 
&#125;
</code></pre>
</blockquote>
<br/>

<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>属于 container adaptor，可以指定其他支持 back()、push_back()、pop_back() 接口的容器作为 stack 的内部结构，如：std::stack&lt;int, std::list&lt;int&gt;&gt; linkedStack 。</code></p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/stack.png">

<blockquote>
<pre><code class="cpp">/*   
*  This is not a true container, but an @e adaptor.  It holds
   *  another container, and provides a wrapper interface to that
   *  container.  The wrapper is what enforces strict
   *  first-in-last-out %stack behavior.
   *
   *  The second template parameter defines the type of the underlying
   *  sequence/container.  It defaults to std::deque, but it can be
   *  any type that supports @c back, @c push_back, and @c pop_back,
   *  such as std::list, std::vector, or an appropriate user-defined
   *  type.
*/
template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;
class stack &#123;
public:
  typedef typename _Sequence::value_type        value_type;
  typedef typename _Sequence::reference        reference;
  typedef typename _Sequence::const_reference    const_reference;
  typedef typename _Sequence::size_type        size_type;
  typedef           _Sequence            container_type;
  _GLIBCXX_NODISCARD bool
    empty() const
  &#123; return c.empty(); &#125;

  size_type size() const
  &#123; return c.size(); &#125;

  reference top() &#123;
    __glibcxx_requires_nonempty();
    return c.back();
  &#125;
  
  const_reference top() const &#123;
    __glibcxx_requires_nonempty();
    return c.back();
  &#125;
    
  template&lt;typename... _Args&gt;
  decltype(auto) emplace(_Args&amp;&amp;... __args) &#123; 
    return c.emplace_back(std::forward&lt;_Args&gt;(__args)...); 
  &#125;

  template&lt;typename _Tp, typename _Seq&gt;
  inline bool
  operator==(const stack&lt;_Tp, _Seq&gt;&amp; __x, const stack&lt;_Tp, _Seq&gt;&amp; __y)
  &#123; return __x.c == __y.c; &#125;
  
  template&lt;typename _Tp, typename _Seq&gt;
  inline bool
  operator&lt;(const stack&lt;_Tp, _Seq&gt;&amp; __x, const stack&lt;_Tp, _Seq&gt;&amp; __y)
  &#123; return __x.c &lt; __y.c; &#125;
  
  // ...
protected:
  //  See queue::c for notes on this name.
  _Sequence c;
&#125;;
</code></pre>
</blockquote>
<br/>

<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><code>同理，属于 container adaptor，可以指定其他支持 back()、push_back()、pop_back() 接口的容器作为 queue 的内部结构，如：std::queue&lt;int, std::list&lt;int&gt;&gt; linkedQueue 。</code></p>
<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/queue.png">

<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Sequence = deque&lt;_Tp&gt; &gt;
class queue &#123;
public:
    typedef typename    _Sequence::value_type        value_type;
    typedef typename    _Sequence::reference        reference;
    typedef typename    _Sequence::const_reference    const_reference;
    typedef typename    _Sequence::size_type        size_type;
    typedef        _Sequence            container_type;
  
    _GLIBCXX_NODISCARD bool empty() const
    &#123; return c.empty(); &#125;

    size_type  size() const
    &#123; return c.size(); &#125;
  
    reference front() &#123;
      __glibcxx_requires_nonempty();
      return c.front();
    &#125;
  
    reference back() &#123;
      __glibcxx_requires_nonempty();
      return c.back();
    &#125;

    void push(const value_type&amp; __x)
    &#123; c.push_back(__x); &#125;
  
    void pop() &#123;
      __glibcxx_requires_nonempty();
      c.pop_front();
    &#125;
  
    template&lt;typename _Tp, typename _Seq&gt;
    inline bool
    operator==(const queue&lt;_Tp, _Seq&gt;&amp; __x, const queue&lt;_Tp, _Seq&gt;&amp; __y)
    &#123; return __x.c == __y.c; &#125;
  
    template&lt;typename _Tp, typename _Seq&gt;
    inline bool
    operator&lt;(const queue&lt;_Tp, _Seq&gt;&amp; __x, const queue&lt;_Tp, _Seq&gt;&amp; __y)
    &#123; return __x.c &lt; __y.c; &#125;

protected:
    _Sequence c;
&#125;;
</code></pre>
</blockquote>
<br/>

<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p><code>非 STL 容器组件，作为 priority_queue 的底层机制。</code></p>
<p><code>binary heap 是 complete binary tree（完全二叉树）的数组实现。</code></p>
<p><code>一个数组 + 一组 heap 算法（插入元素、删除元素、取极值、排列成 heap）。</code></p>
<p><code>对于整个堆，以及子堆， 最大堆（最小堆）的最大（最小值）在（子）堆的根节点。</code></p>
<p><br/><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/binary-heap.png"></p>
<br/>

<h3 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap()"></a>push_heap()</h3><p><code>为了满足完全二叉树的条件：</code></p>
<p><code>首先，新加入元素置于尾部。</code></p>
<p><code>其次，为了满足 max-heap 或者 min-heap 等的条件，需要做 percolate up(上溯) 调整。</code></p>
<p><code>令当前洞号为添加的新尾部节点，和其父节点的键值对比，如果符合对比策略，就让父节点和子节点对换位置，更新洞号，一直上溯，直到不需要对换或到根节点为止。</code></p>
<br/>

<blockquote>
<pre><code class="cpp">template&lt;typename _RandomAccessIterator&gt;
inline void
push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last) &#123;
typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type
      _DistanceType;
//...
// 调用如下函数时，新元素已经置于底部容器最尾端
__gnu_cxx::__ops::_Iter_less_val __comp;
_ValueType __value = _GLIBCXX_MOVE(*(__last - 1));
std::__push_heap(__first, _DistanceType((__last - __first) - 1),
                _DistanceType(0), _GLIBCXX_MOVE(__value), __comp);
&#125;

// 允许指定比较策略
template&lt;typename _RandomAccessIterator, typename _Distance, typename _Tp,
typename _Compare&gt;
void __push_heap(_RandomAccessIterator __first,
           _Distance __holeIndex, _Distance __topIndex, _Tp __value,
           _Compare&amp; __comp) &#123;
    // 找到压入的尾端节点的父节点位置
    _Distance __parent = (__holeIndex - 1) / 2;
    // 当尚未到达顶端，且父节点在 __comp 比较策略下符合 value 值 
    while (__holeIndex &gt; __topIndex &amp;&amp; __comp(__first + __parent, __value)) &#123;
       // 洞值（当前子节点）为父节点值
       *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __parent));
       // 调整洞号，继续 percolateUp(上溯)
       __holeIndex = __parent;
       __parent = (__holeIndex - 1) / 2;
    &#125; // 持续到满足 heap 次序特性或者顶端为止
    // 更新终止处的值
    *(__first + __holeIndex) = _GLIBCXX_MOVE(__value);
&#125;
</code></pre>
</blockquote>
<br/>

<img title="push_heap" src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/push-heap.png">

<br/>

<h3 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap()"></a>pop_heap()</h3><p><code>要保持完全二叉树的条件：</code></p>
<p><code>首先，记录最后一个叶子节点（即尾节点）的值备用。</code></p>
<p><code>其次，将根节点的值替换到尾节点，不会被立即弹出。如果需要，可后续调用 back()、pop_back() 访取。</code></p>
<p><code>为了满足 max-heap 或者 min-heap 等的条件，需要做 percolate down(下溯) 调整。</code></p>
<p><code>令洞号为根节点，和其孩子节点（包括左孩子和右孩子）做对比，如果符合某种比较策略，就互换值，更新洞号，继续下溯，直到子堆叶子节点为止，然后将整个堆的最后一个叶子节点（最下层，最右边）的值，设给这个“已经到达子堆叶层的洞号节点”，再对这个洞号节点进行 percolate up （上溯）。</code></p>
<br/>

<blockquote>
<pre><code class="cpp">template&lt;typename _RandomAccessIterator, typename _Compare&gt;
inline void pop_heap(_RandomAccessIterator __first,
                            _RandomAccessIterator __last, _Compare __comp) &#123;
  if (__last - __first &gt; 1) &#123;
    // 自定义 compare 规则
    typedef __decltype(__comp) _Cmp;
    __gnu_cxx::__ops::_Iter_comp_iter&lt;_Cmp&gt; __cmp(_GLIBCXX_MOVE(__comp));
    --__last; // 调整 last 指向最后一个叶子节点
    std::__pop_heap(__first, __last, __last, __cmp);
  &#125;
&#125;

template&lt;typename _RandomAccessIterator, typename _Compare&gt;
inline void __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                                          _RandomAccessIterator __result, _Compare&amp; __comp) &#123;
  typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type
    _ValueType;
  typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type
    _DistanceType;
  // 先记录尾节点（最后一个叶子节点值）
  _ValueType __value = _GLIBCXX_MOVE(*__result);
  // 将要 pop 的元素（即容器的第一个元素）赋值到 尾节点
  *__result = _GLIBCXX_MOVE(*__first);
  // _DistanceType(0) 代表以根节点为洞号，进行下溯，重新调整 heap
  std::__adjust_heap(__first, _DistanceType(0),
                     _DistanceType(__last - __first),
                     _GLIBCXX_MOVE(__value), __comp);
&#125;

template&lt;typename _RandomAccessIterator, typename _Distance,
typename _Tp, typename _Compare&gt;
void __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
                           _Distance __len, _Tp __value, _Compare __comp) &#123;
 const _Distance __topIndex = __holeIndex;
 _Distance __secondChild = __holeIndex;

 // (__len - 1) / 2 指向的是最后一个非叶子节点的节点
 while (__secondChild &lt; (__len - 1) / 2) &#123;
         // 首先，定位到右孩子节点
    __secondChild = 2 * (__secondChild + 1);
    // 如果左孩子节点比右孩子节点更符合 comp 策略（大），则定位到左孩子节点
    if (__comp(__first + __secondChild, __first + (__secondChild - 1)))
      __secondChild--;
    // 让当前洞号的孩子节点覆盖当前洞号值
    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + __secondChild));
    // 更新当前洞号指向孩子节点，继续下溯
    __holeIndex = __secondChild;
 &#125; // 如果当前洞号的孩子节点大于尾节点的父节点停止下溯

 // 特殊处理
 // __len &amp; 1 == 0 表示 __len 为偶数， 
 // 即尾端结点属于左孩子节点类型,
 // 并且当前 __secondChild 指向尾节点的父节点
 if ((__len &amp; 1) == 0 &amp;&amp; __secondChild == (__len - 2) / 2) &#123;
   // 将 __secondChild 定位到最尾端节点（左孩子节点类型）
    __secondChild = 2 * (__secondChild + 1);

    *(__first + __holeIndex) = _GLIBCXX_MOVE(*(__first + (__secondChild - 1)));
    __holeIndex = __secondChild - 1;
  &#125;
  __decltype(__gnu_cxx::__ops::__iter_comp_val(_GLIBCXX_MOVE(__comp)))
    __cmp(_GLIBCXX_MOVE(__comp));
  std::__push_heap(__first, __holeIndex, __topIndex, _GLIBCXX_MOVE(__value), __cmp);
&#125;
</code></pre>
</blockquote>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/pop-heap.png">

<p><br/><br/></p>
<h3 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap()"></a>sort_heap()</h3><blockquote>
<pre><code class="cpp">template&lt;typename _RandomAccessIterator, typename _Compare&gt;
void __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
                 _Compare&amp; __comp) &#123;
  // 执行一次 __pop_heap()，（根据__comp比较策略）极值放在尾端
  // 再执行一次 __pop_heap()，次极值放在新的尾端，
  // 如此下去，最后得到的便是排好序的区间 [first, last)
  while (__last - __first &gt; 1) &#123;
    --__last;
    std::__pop_heap(__first, __last, __last, __comp);
  &#125;
&#125;
</code></pre>
</blockquote>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/sort-heap.png">

<br/>

<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap()"></a>make_heap()</h3><blockquote>
<pre><code class="cpp">template&lt;typename _RandomAccessIterator, typename _Compare&gt;
void __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
         _Compare&amp; __comp) &#123;
  typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::value_type _ValueType;
  typedef typename iterator_traits&lt;_RandomAccessIterator&gt;::difference_type _DistanceType;

  if (__last - __first &lt; 2)
    return;

  const _DistanceType __len = __last - __first;
    // 由于任何叶节点都不需要执行 percolate down，所以指定 __parent = (__len - 2) / 2
  // parent 对应的是 之前提及的 holeIndex
  _DistanceType __parent = (__len - 2) / 2;
  while (true) &#123;
    // 重排以 parent 为首的子树。
    _ValueType __value = _GLIBCXX_MOVE(*(__first + __parent));
    std::__adjust_heap(__first, __parent, __len, _GLIBCXX_MOVE(__value), __comp);
    if (__parent == 0)
      return;
    __parent--;
  &#125;
&#125;
</code></pre>
</blockquote>
<br/>

<p><strong>__adjust_heap() 中 最后一步 __push_heap() 的重要性</strong></p>
<br/>

<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/priority_queue.png">

<br/>

<blockquote>
<pre><code class="cpp">template&lt;typename _Tp, typename _Sequence = vector&lt;_Tp&gt;,
typename _Compare  = less&lt;typename _Sequence::value_type&gt; &gt;
class priority_queue &#123;

#if __cplusplus &gt;= 201103L
  template&lt;typename _Alloc&gt;
  using _Uses = typename
  enable_if&lt;uses_allocator&lt;_Sequence, _Alloc&gt;::value&gt;::type;

  #if __cplusplus &gt;= 201703L
  static_assert(is_same&lt;_Tp, typename _Sequence::value_type&gt;::value,
                &quot;value_type must be the same as the underlying container&quot;);
  #endif // C++17
#endif // C++11

public:
  typedef typename    _Sequence::value_type        value_type;
  typedef typename    _Sequence::reference        reference;
  typedef typename    _Sequence::const_reference    const_reference;
  typedef typename    _Sequence::size_type        size_type;
  typedef        _Sequence            container_type;
  typedef       _Compare                value_compare;

protected:
  _Sequence  c;
  _Compare   comp;

public:
  explicit priority_queue(const _Compare&amp; __x, const _Sequence&amp; __s)
    : c(__s), comp(__x) &#123; 
      std::make_heap(c.begin(), c.end(), comp); 
    &#125;

  _GLIBCXX_NODISCARD bool empty() const &#123; 
    return c.empty();
  &#125;

  size_type size() const &#123; 
    return c.size(); 
  &#125;

  const_reference top() const &#123;
    __glibcxx_requires_nonempty();
    return c.front();
  &#125;

  void push(const value_type&amp; __x) &#123;
    c.push_back(__x);
    std::push_heap(c.begin(), c.end(), comp);
  &#125;
  
  void pop() &#123;
    __glibcxx_requires_nonempty();
    // 取出极值放在尾端，重排 heap
    std::pop_heap(c.begin(), c.end(), comp);
    // 真正意义的取出元素
    c.pop_back();
  &#125;

  template&lt;typename... _Args&gt; void emplace(_Args&amp;&amp;... __args) &#123;
    c.emplace_back(std::forward&lt;_Args&gt;(__args)...);
    std::push_heap(c.begin(), c.end(), comp);
  &#125;
&#125;;
</code></pre>
</blockquote>
<br/>

<br/>

<h2 id="slist"><a href="#slist" class="headerlink" title="slist"></a>slist</h2><br/>

<table>
<thead>
<tr>
<th align="center">slist</th>
<th align="center">list</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>singly</strong> linked list</td>
<td align="center"><strong>double</strong> linked list</td>
</tr>
<tr>
<td align="center">Forward Iterator</td>
<td align="center">Bidirectional Iterator</td>
</tr>
<tr>
<td align="center">头插法插入新元素，只提供 <strong>push_front()</strong></td>
<td align="center"></td>
</tr>
</tbody></table>
<br/>

<h3 id="slist-的节点和迭代器数据结构"><a href="#slist-的节点和迭代器数据结构" class="headerlink" title="slist 的节点和迭代器数据结构"></a>slist 的节点和迭代器数据结构</h3><blockquote>
<pre><code class="cpp">struct _Slist_node_base &#123;
    _Slist_node_base* _M_next;
&#125;;

template &lt;class _Tp&gt;
struct _Slist_node : public _Slist_node_base &#123;
    _Tp _M_data;
&#125;;

struct _Slist_iterator_base &#123;
  typedef size_t                    size_type;
  typedef ptrdiff_t                 difference_type;
  typedef std::forward_iterator_tag iterator_category; // 单向

  _Slist_node_base* _M_node;

  _Slist_iterator_base(_Slist_node_base* __x) : _M_node(__x) &#123;&#125;

  void _M_incr() &#123; 
   _M_node = _M_node-&gt;_M_next;     // 前进一个节点
  &#125;

  bool operator==(const _Slist_iterator_base&amp; __x) const &#123; 
   return _M_node == __x._M_node; 
  &#125;

  bool operator!=(const _Slist_iterator_base&amp; __x) const &#123; 
   return _M_node != __x._M_node; 
  &#125;
&#125;;

// 迭代器结构
template &lt;class _Tp, class _Ref, class _Ptr&gt;
struct _Slist_iterator : public _Slist_iterator_base &#123;
  typedef _Slist_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;
  typedef _Slist_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;
  typedef _Slist_iterator&lt;_Tp, _Ref, _Ptr&gt;             _Self;

  typedef _Tp              value_type;
  typedef _Ptr             pointer;
  typedef _Ref             reference;
  typedef _Slist_node&lt;_Tp&gt; _Node;

  explicit _Slist_iterator(_Node* __x) : _Slist_iterator_base(__x) &#123;&#125;
    // 因为       iterator end()  &#123; return iterator(0); &#125;
  _Slist_iterator() : _Slist_iterator_base(0) &#123;&#125;

  _Slist_iterator(const iterator&amp; __x) : _Slist_iterator_base(__x._M_node) &#123;&#125;

  reference operator*() const &#123; 
   return ((_Node*) _M_node)-&gt;_M_data; 
  &#125;

  pointer operator-&gt;() const &#123; 
   return &amp;(operator*()); 
  &#125;

  _Self&amp; operator++() &#123;
   _M_incr();        // 前进一个节点
   return *this;
  &#125;

  _Self operator++(int) &#123;
   _Self __tmp = *this;
   _M_incr();        // 前进一个节点
   return __tmp;
  &#125;
&#125;;
</code></pre>
</blockquote>
<br/>

<img src="https://github.com/JoyChenNo1/JoyChenNo1.github.io/raw/master/BlogImages/STL/slist-node-and-iterator.png">



<br/>

<br/>

<h3 id="slist-之-新节点创建"><a href="#slist-之-新节点创建" class="headerlink" title="slist 之 新节点创建"></a>slist 之 新节点创建</h3><blockquote>
<pre><code class="cpp">inline _Slist_node_base*
    __slist_make_link(_Slist_node_base* __prev_node, _Slist_node_base* __new_node) &#123;
    __new_node-&gt;_M_next = __prev_node-&gt;_M_next;
    __prev_node-&gt;_M_next = __new_node;
    return __new_node;
&#125;
</code></pre>
</blockquote>
<br/>

<blockquote>
<pre><code class="cpp">// _Slist_base
template &lt;class _Tp, class _Alloc&gt;
struct _Slist_base : public _Alloc::template rebind&lt;_Slist_node&lt;_Tp&gt; &gt;::other &#123;
  typedef typename _Alloc::template rebind&lt;_Slist_node&lt;_Tp&gt; &gt;::other
    _Node_alloc;
  typedef _Alloc allocator_type;

  allocator_type get_allocator() const &#123; 
    return *static_cast&lt;const _Node_alloc*&gt;(this); 
  &#125;

  _Slist_base(const allocator_type&amp; __a) : _Node_alloc(__a) &#123; 
    this-&gt;_M_head._M_next = 0; 
  &#125;

  ~_Slist_base() &#123; 
    _M_erase_after(&amp;this-&gt;_M_head, 0); 
  &#125;

protected:
  _Slist_node_base _M_head; // 头部，非指针类型

  _Slist_node&lt;_Tp&gt;* _M_get_node() &#123; 
    return _Node_alloc::allocate(1); 
  &#125;

  void _M_put_node(_Slist_node&lt;_Tp&gt;* __p) &#123; 
    _Node_alloc::deallocate(__p, 1); 
  &#125;

protected:
  _Slist_node_base* _M_erase_after(_Slist_node_base* __pos) &#123;
    _Slist_node&lt;_Tp&gt;* __next = (_Slist_node&lt;_Tp&gt;*) (__pos-&gt;_M_next);
    _Slist_node_base* __next_next = __next-&gt;_M_next;
    __pos-&gt;_M_next = __next_next;
    get_allocator().destroy(&amp;__next-&gt;_M_data);
    _M_put_node(__next);
    return __next_next;
  &#125;
  _Slist_node_base* _M_erase_after(_Slist_node_base*, _Slist_node_base*);
&#125;;

// slist
template &lt;class _Tp, class _Alloc = allocator&lt;_Tp&gt; &gt;
class slist : private _Slist_base&lt;_Tp,_Alloc&gt; &#123;

private:
  typedef _Slist_base&lt;_Tp,_Alloc&gt; _Base;
  
public:
  typedef _Tp               value_type;
  typedef value_type*       pointer;
  typedef const value_type* const_pointer;
  typedef value_type&amp;       reference;
  typedef const value_type&amp; const_reference;
  typedef size_t            size_type;
  typedef ptrdiff_t         difference_type;

  typedef _Slist_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;
  typedef _Slist_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;
  
    // 构造元素 
  _Node* _M_create_node(const value_type&amp; __x) &#123;
    _Node* __node = this-&gt;_M_get_node();
    __try &#123;
      get_allocator().construct(&amp;__node-&gt;_M_data, __x);
      __node-&gt;_M_next = 0;
    &#125;
    __catch(...) &#123;
      this-&gt;_M_put_node(__node);
      __throw_exception_again;
    &#125;
    return __node;
  &#125;
  // 析构元素
  void _M_put_node(_Slist_node&lt;_Tp&gt;* __p) &#123; 
    _Node_alloc::deallocate(__p, 1); 
  &#125;

  iterator begin() &#123; 
    return iterator((_Node*)this-&gt;_M_head._M_next); 
  &#125;

  const_iterator end() const &#123; 
    return const_iterator(0); 
  &#125;
  // 互换 slist
    void  swap(slist&amp; __x) &#123; 
    std::swap(this-&gt;_M_head._M_next, __x._M_head._M_next); 
  &#125;
  
  const_reference front() const &#123; 
    return ((_Node*) this-&gt;_M_head._M_next)-&gt;_M_data; 
  &#125;
    // 头插法插入一个元素
  void push_front(const value_type&amp; __x) &#123; 
    __slist_make_link(&amp;this-&gt;_M_head, _M_create_node(__x)); 
  &#125;
  // 弹出并删除头部元素
  void pop_front() &#123;
    _Node* __node = (_Node*) this-&gt;_M_head._M_next;
    this-&gt;_M_head._M_next = __node-&gt;_M_next;
    get_allocator().destroy(&amp;__node-&gt;_M_data);
    this-&gt;_M_put_node(__node);
  &#125;
  // 擦除元素
  iterator erase(iterator __pos) &#123; 
    return iterator((_Node*) this-&gt;_M_erase_after
                    (__slist_previous(&amp;this-&gt;_M_head, __pos._M_node)));
  &#125;
&#125;;
</code></pre>
</blockquote>
<br/>

<h3 id="list-其他方法"><a href="#list-其他方法" class="headerlink" title="list 其他方法"></a>list 其他方法</h3><blockquote>
<pre><code class="cpp">inline _Slist_node_base*
  __slist_previous(_Slist_node_base* __head, const _Slist_node_base* __node) &#123;
  while (__head &amp;&amp; __head-&gt;_M_next != __node)
    __head = __head-&gt;_M_next;
  return __head;
&#125;

const_iterator previous(const_iterator __pos) const &#123; 
  return const_iterator((_Node*) __slist_previous(&amp;this-&gt;_M_head, __pos._M_node)); 
&#125;

_Node* _M_insert_after(_Node_base* __pos, const value_type&amp; __x) &#123; 
  return (_Node*) (__slist_make_link(__pos, _M_create_node(__x))); 
&#125;

iterator insert(iterator __pos) &#123; 
  return iterator(_M_insert_after(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),
                                  value_type())); 
&#125;

void insert(iterator __pos, size_type __n, const value_type&amp; __x) &#123;
  _M_insert_after_fill(__slist_previous(&amp;this-&gt;_M_head, __pos._M_node),  __n, __x); 
&#125;
</code></pre>
</blockquote>
<br/>


        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2021/05/31/STL/%E6%8B%86%E4%B9%A6%E7%B3%BB%E5%88%97%E4%B9%8B%E3%80%8ASTL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E3%80%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iterators%EF%BC%89/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/me.png" alt="Joy Chen's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        joychenisno1@gmail.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="joychenisno1@gmail.com" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2021/06/">六月 2021<span class="sidebar_archives-count">1</span></a></li><li><a class="sidebar_archives-link" href="/archives/2021/05/">五月 2021<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2021/03/">三月 2021<span class="sidebar_archives-count">5</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">chrome_reader_mode</i>
                
                分类
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
                <li>
                <a class="sidebar_archives-link" href="/categories/C-%E6%96%B0%E7%89%B9%E6%80%A7/">C++新特性<span class="sidebar_archives-count">5</span></a></li><li><a class="sidebar_archives-link" href="/categories/STL/">STL<span class="sidebar_archives-count">4</span></a>
            </ul>
        </li>
        
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-twitter">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-facebook">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-gplus">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    

    <!-- V2EX -->
    

    <!-- Segmentfault -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;<span year></span>&nbsp;进阶之路
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?Bn9UzEm8RrBSxqyZB0zPjA==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>













<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('
<link rel="stylesheet" href="/css/uc.css">
');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->


<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    var copyrightNow = new Date().getFullYear();
    var textContent = document.querySelector('span[year]')

    copyrightSince = 0000;
    if (copyrightSince === copyrightNow||copyrightSince === 0000) {
        textContent.textContent = copyrightNow
    } else {
        textContent.textContent = copyrightSince + ' - ' + copyrightNow
    }

    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.6 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        </body>
    
</html>
